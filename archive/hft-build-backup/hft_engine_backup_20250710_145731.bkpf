{
    "metadata":  {
                     "projectName":  "hft_engine",
                     "backupVersion":  "1.0",
                     "fileCount":  27,
                     "projectRoot":  "C:\\Users\\rajab\\CLionProjects\\hft_engine",
                     "generatedBy":  "HFT Engine Backup Script (PowerShell)",
                     "backupDate":  "2025-07-10 14:57:31"
                 },
    "files":  [
                  {
                      "size":  1735,
                      "relativePath":  "CMakeLists.txt",
                      "extension":  ".txt",
                      "lastModified":  "2025-07-10 13:57:30",
                      "directory":  "",
                      "fileName":  "CMakeLists.txt",
                      "type":  "cmake",
                      "content":  "cmake_minimum_required(VERSION 3.16)\\nproject(HFTEngine CXX)\\n\\nset(CMAKE_CXX_STANDARD 17)\\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\\nset(CMAKE_CXX_FLAGS \\\"${CMAKE_CXX_FLAGS} -pthread\\\")\\n\\n# Enable coverage reporting\\noption(ENABLE_COVERAGE \\\"Enable code coverage reporting\\\" OFF)\\nif(ENABLE_COVERAGE)\\n    set(CMAKE_CXX_FLAGS \\\"${CMAKE_CXX_FLAGS} --coverage -fprofile-arcs -ftest-coverage\\\")\\n    set(CMAKE_EXE_LINKER_FLAGS \\\"${CMAKE_EXE_LINKER_FLAGS} --coverage\\\")\\nendif()\\n\\n# --- External Dependencies ---\\nfind_package(Boost 1.74 REQUIRED COMPONENTS system thread)\\nfind_package(OpenSSL REQUIRED)\\nfind_package(nlohmann_json 3.2.0 REQUIRED)\\n\\n# --- Vendored WebSocket++ (compatible v0.8.2) ---\\nadd_library(websocketpp INTERFACE)\\n# CORRECTED: Point to the directory CONTAINING the websocketpp folder\\ntarget_include_directories(websocketpp INTERFACE\\n        ${CMAKE_SOURCE_DIR}/external/websocketpp\\n)\\n\\n# --- Core Engine Library ---\\nadd_library(hft_core\\n        src/matching_engine.cpp\\n        src/order_book.cpp\\n        src/websocket_client.cpp\\n        src/auth_manager.cpp\\n        src/trading_client.cpp\\n        src/ui_manager.cpp\\n)\\n\\n# Public headers for hft_core\\ntarget_include_directories(hft_core PUBLIC\\n        $\u003cBUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include\u003e\\n        $\u003cINSTALL_INTERFACE:include\u003e\\n)\\n\\n# Link in Boost, OpenSSL, JSON, and our vendored wspp\\ntarget_link_libraries(hft_core\\n        PUBLIC\\n        Boost::system\\n        Boost::thread\\n        OpenSSL::SSL\\n        OpenSSL::Crypto\\n        nlohmann_json::nlohmann_json\\n        websocketpp\\n)\\n\\n# --- Main Executable ---\\nadd_executable(hft_engine\\n        src/main.cpp\\n)\\ntarget_link_libraries(hft_engine\\n        PRIVATE\\n        hft_core\\n)\\n\\n# --- Testing Setup ---\\nenable_testing()\\nadd_subdirectory(tests)\\n"
                  },
                  {
                      "size":  48,
                      "relativePath":  "config.json",
                      "extension":  ".json",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "",
                      "fileName":  "config.json",
                      "type":  "configuration",
                      "content":  "{\\r\\n  \\\"symbol\\\": \\\"btcusdt\\\",\\r\\n  \\\"book_depth\\\": 10\\r\\n}"
                  },
                  {
                      "size":  758,
                      "relativePath":  "Dockerfile",
                      "extension":  "",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "",
                      "fileName":  "Dockerfile",
                      "type":  "special",
                      "content":  "# Stage 1: Builder\\r\\nFROM ubuntu:22.04 AS builder\\r\\nRUN apt-get update \u0026\u0026 apt-get install -y \\\\\\\\\\r\\n    build-essential \\\\\\\\\\r\\n    cmake \\\\\\\\\\r\\n    git \\\\\\\\\\r\\n    libssl-dev \\\\\\\\\\r\\n    libboost-system-dev \\\\\\\\\\r\\n    libboost-thread-dev \\\\\\\\\\r\\n    nlohmann-json3-dev\\r\\n\\r\\n# Clone and build websocketpp\\r\\nRUN git clone https://github.com/zaphoyd/websocketpp.git /websocketpp\\r\\n\\r\\nWORKDIR /app\\r\\nCOPY . .\\r\\nRUN mkdir build \u0026\u0026 cd build \u0026\u0026 \\\\\\\\\\r\\n    cmake -DCMAKE_PREFIX_PATH=/websocketpp .. \u0026\u0026 \\\\\\\\\\r\\n    make -j$(nproc)\\r\\n\\r\\n# Stage 2: Runner\\r\\nFROM ubuntu:22.04\\r\\nRUN apt-get update \u0026\u0026 apt-get install -y libssl3 libboost-system1.74.0 libboost-thread1.74.0 \u0026\u0026 rm -rf /var/lib/apt/lists/*\\r\\nWORKDIR /app\\r\\nCOPY --from=builder /app/build/hft_engine .\\r\\nCOPY --from=builder /app/config.json .\\r\\nCMD [\\\"./hft_engine\\\"]"
                  },
                  {
                      "size":  7719,
                      "relativePath":  "README.md",
                      "extension":  ".md",
                      "lastModified":  "2025-07-10 13:36:17",
                      "directory":  "",
                      "fileName":  "README.md",
                      "type":  "documentation",
                      "content":  "# High-Frequency Trading (HFT) Engine\\r\\n\\r\\nA professional-grade **High-Frequency Trading Engine** built in C++ that connects to Binance cryptocurrency exchange via WebSocket to receive real-time market data and maintain a live order book for algorithmic trading strategies.\\r\\n\\r\\n## ðŸŽ¯ Project Overview\\r\\n\\r\\nThis HFT engine demonstrates institutional-grade trading infrastructure with microsecond-level optimizations. It serves as a foundation for:\\r\\n\\r\\n- **Cryptocurrency Trading Bots**\\r\\n- **Market Making Algorithms** \\r\\n- **Statistical Arbitrage Strategies**\\r\\n- **Real-time Market Analysis**\\r\\n- **Backtesting Infrastructure**\\r\\n\\r\\n## ðŸš€ What This Project Achieves\\r\\n\\r\\n1. **Real-time Market Data Processing**: Connects to Binance\u0027s WebSocket API for live order book updates\\r\\n2. **High-Performance Order Book Management**: Maintains accurate, real-time market depth data\\r\\n3. **Ultra-Low Latency Architecture**: Built for algorithmic trading with microsecond optimizations\\r\\n4. **Market Analysis Foundation**: Provides real-time market conditions for trading decisions\\r\\n\\r\\n**âš ï¸ Important Note**: This is a **READ-ONLY** market data system. It does **NOT** execute actual trades or place orders. It only displays real-time market data for analysis and strategy development.\\r\\n\\r\\n## ðŸ—ï¸ Architecture \u0026 Components\\r\\n\\r\\n### Core Components\\r\\n\\r\\n| Component | File | Purpose |\\r\\n|-----------|------|----------|\\r\\n| **WebSocket Client** | `websocket_client.h/cpp` | Real-time connection to Binance API |\\r\\n| **Matching Engine** | `matching_engine.h/cpp` | High-performance message processor |\\r\\n| **Order Book** | `order_book.h/cpp` | Market depth data management |\\r\\n| **Command System** | `command.h` | Internal communication structures |\\r\\n| **Configuration** | `config.json` | Trading pair and display settings |\\r\\n\\r\\n### Technical Features\\r\\n\\r\\n- **Lock-free Programming**: Eliminates thread contention for ultra-low latency\\r\\n- **Cache Optimization**: 64-byte aligned structures prevent false sharing\\r\\n- **Asynchronous Processing**: Separates I/O from computation\\r\\n- **Multi-threading**: Dedicated threads for data reception and processing\\r\\n- **Memory Efficient**: Optimized STL containers for trading data\\r\\n\\r\\n## ðŸ“Š Real-time Output Example\\r\\n\\r\\n```\\r\\nConnecting to Binance for symbol: \\\"btcusdt\\\"\\r\\nPress Ctrl+C to exit.\\r\\n[2025-07-10 07:54:52] [connect] Successful connection\\r\\n\\r\\n--- ORDER BOOK ---\\r\\n------------------------------------\\r\\n|       BIDS       |       ASKS       |\\r\\n| Price    | Qty     | Price    | Qty     |\\r\\n------------------------------------\\r\\n| 111224.58 |       5 | 111224.59 |       2 |\\r\\n| 111224.57 |       0 | 111224.60 |       0 |\\r\\n| 111223.89 |       0 | 111225.00 |       0 |\\r\\n| 111223.88 |       0 | 111226.00 |       0 |\\r\\n------------------------------------\\r\\n```\\r\\n\\r\\n## ðŸ”„ Data Flow Process\\r\\n\\r\\n1. **WebSocket Connection**: Connects to `wss://stream.binance.com:9443/ws/btcusdt@depth20@100ms`\\r\\n2. **Data Reception**: Receives order book updates every 100ms\\r\\n3. **JSON Parsing**: Converts market data to internal command format\\r\\n4. **Lock-free Queue**: Passes data through ultra-fast message queue\\r\\n5. **Order Book Update**: Updates bid/ask levels in real-time\\r\\n6. **Display**: Renders formatted order book to terminal\\r\\n\\r\\n## âš¡ Performance Optimizations\\r\\n\\r\\n- **Lock-free Queue**: Boost\u0027s lock-free queue for 64K commands\\r\\n- **Cache Line Alignment**: Prevents CPU cache false sharing\\r\\n- **Single Writer Pattern**: Eliminates lock contention\\r\\n- **Memory Pool**: Reduces allocation overhead\\r\\n- **Branch Prediction**: Optimized conditional logic\\r\\n\\r\\n## ðŸ“ˆ Trading vs. Display-Only Functionality\\r\\n\\r\\n### Current State: **DISPLAY-ONLY** ðŸ“Š\\r\\n\\r\\nThis project is currently a **market data viewer** and does **NOT** execute any actual trading operations. Here\u0027s what it does:\\r\\n\\r\\n**âœ… What it DOES:**\\r\\n- Connects to Binance WebSocket API\\r\\n- Receives real-time market data\\r\\n- Displays live order book updates\\r\\n- Maintains accurate bid/ask spreads\\r\\n- Provides foundation for trading algorithms\\r\\n\\r\\n**âŒ What it does NOT do:**\\r\\n- Place buy/sell orders\\r\\n- Execute trades\\r\\n- Manage positions or portfolio\\r\\n- Handle authentication for trading\\r\\n- Risk management or position sizing\\r\\n\\r\\n### ðŸš€ Future Trading Extension\\r\\n\\r\\nTo convert this into an actual trading system, you would need to add:\\r\\n\\r\\n1. **Binance Trading API Integration**\\r\\n   ```cpp\\r\\n   // Example: Order placement functionality\\r\\n   class TradingClient {\\r\\n       void place_order(Side side, Price price, Quantity qty);\\r\\n       void cancel_order(OrderId id);\\r\\n   };\\r\\n   ```\\r\\n\\r\\n2. **Authentication \u0026 API Keys**\\r\\n   - Binance API key and secret\\r\\n   - HMAC signature generation\\r\\n   - Rate limiting compliance\\r\\n\\r\\n3. **Trading Strategy Logic**\\r\\n   ```cpp\\r\\n   class MarketMakingStrategy {\\r\\n       void on_order_book_update(const OrderBook\u0026 book);\\r\\n       void place_quotes(Price bid, Price ask);\\r\\n   };\\r\\n   ```\\r\\n\\r\\n4. **Risk Management**\\r\\n   - Position limits\\r\\n   - Stop-loss mechanisms\\r\\n   - Exposure monitoring\\r\\n\\r\\n### âš ï¸ Trading Risks Warning\\r\\n\\r\\n**IMPORTANT**: Adding actual trading functionality involves significant financial risk:\\r\\n- Cryptocurrency markets are highly volatile\\r\\n- Algorithmic trading can lead to rapid losses\\r\\n- Always test strategies in simulation first\\r\\n- Never risk more than you can afford to lose\\r\\n- Consider regulatory compliance in your jurisdiction\\r\\n\\r\\n## Prerequisites\\r\\n\\r\\n- Docker\\r\\n- A C++20 compatible compiler (GCC 11+ or Clang 14+)\\r\\n- CMake (3.16+)\\r\\n- Boost libraries (`system`, `thread`)\\r\\n- OpenSSL\\r\\n- `nlohmann/json` library\\r\\n\\r\\nOn **Ubuntu 22.04**, you can install C++ dependencies with:\\r\\n```bash\\r\\nsudo apt update \u0026\u0026 sudo apt install -y \\\\\\\\\\r\\n    build-essential cmake git libssl-dev \\\\\\\\\\r\\n    libboost-all-dev nlohmann-json3-dev pkg-config\\r\\n```\\r\\n\\r\\n## ðŸ› ï¸ How to Build and Run\\r\\n\\r\\n### Method 1: Ubuntu/WSL (Recommended)\\r\\n\\r\\n1. **Install Dependencies:**\\r\\n   ```bash\\r\\n   sudo apt update \u0026\u0026 sudo apt install -y build-essential cmake libboost-all-dev libssl-dev nlohmann-json3-dev pkg-config git\\r\\n   ```\\r\\n\\r\\n2. **Clone Repository \u0026 Dependencies:**\\r\\n   ```bash\\r\\n   git clone \u003cyour-repo-url\u003e\\r\\n   cd hft_engine\\r\\n   mkdir -p external \u0026\u0026 cd external\\r\\n   git clone https://github.com/zaphoyd/websocketpp.git\\r\\n   cd ..\\r\\n   ```\\r\\n\\r\\n3. **Build Project:**\\r\\n   ```bash\\r\\n   mkdir build \u0026\u0026 cd build\\r\\n   cmake ..\\r\\n   make -j4\\r\\n   ```\\r\\n\\r\\n4. **Configure Trading Pair:**\\r\\n   ```bash\\r\\n   cp ../config.json .\\r\\n   # Edit config.json to change symbol (default: \\\"btcusdt\\\")\\r\\n   ```\\r\\n\\r\\n5. **Run the Engine:**\\r\\n   ```bash\\r\\n   ./hft_engine\\r\\n   ```\\r\\n\\r\\n### Method 2: Windows with WSL\\r\\n\\r\\n1. **Enable WSL and install Ubuntu:**\\r\\n   ```powershell\\r\\n   wsl --install -d Ubuntu-24.04\\r\\n   ```\\r\\n\\r\\n2. **Open WSL terminal and follow Method 1 steps above**\\r\\n\\r\\n3. **Navigate to Windows project folder:**\\r\\n   ```bash\\r\\n   cd /mnt/c/Users/[username]/CLionProjects/hft_engine\\r\\n   ```\\r\\n\\r\\n### Method 3: Native Windows (Advanced)\\r\\n\\r\\n1. **Install dependencies via vcpkg or manually**\\r\\n2. **Use Visual Studio with CMake support**\\r\\n3. **Configure paths for Boost, OpenSSL, nlohmann_json**\\r\\n\\r\\n### Expected Output\\r\\n\\r\\nSuccessful run shows:\\r\\n```\\r\\nConnecting to Binance for symbol: \\\"btcusdt\\\"\\r\\nPress Ctrl+C to exit.\\r\\n[2025-07-10 07:54:52] [connect] Successful connection\\r\\n[2025-07-10 07:54:52] [connect] WebSocket Connection 57.182.125.171:9443\\r\\n\\r\\n--- ORDER BOOK ---\\r\\n------------------------------------\\r\\n|       BIDS       |       ASKS       |\\r\\n| Price    | Qty     | Price    | Qty     |\\r\\n------------------------------------\\r\\n| 111224.58 |       5 | 111224.59 |       2 |\\r\\n...\\r\\n```\\r\\n\\r\\n## How to Build and Run (with Docker)\\r\\n\\r\\n1.  **Build the Docker Image:**\\r\\n    ```bash\\r\\n    docker build -t hft-engine .\\r\\n    ```\\r\\n\\r\\n2.  **Run the Container:**\\r\\n    ```bash\\r\\n    docker run -it --rm hft-engine\\r\\n    ```"
                  },
                  {
                      "size":  1658,
                      "relativePath":  "include\\hft\\auth_manager.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 13:43:22",
                      "directory":  "include\\hft",
                      "fileName":  "auth_manager.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \u003cstring\u003e\\r\\n#include \u003coptional\u003e\\r\\n#include \u003cmemory\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    class AuthManager {\\r\\n    public:\\r\\n        struct Credentials {\\r\\n            std::string api_key;\\r\\n            std::string secret_key;\\r\\n            std::string passphrase; // For some exchanges\\r\\n        };\\r\\n\\r\\n        AuthManager();\\r\\n        ~AuthManager();\\r\\n\\r\\n        // Load credentials from environment variables or config file\\r\\n        bool load_credentials();\\r\\n        bool load_credentials_from_file(const std::string\u0026 config_path);\\r\\n        bool set_credentials(const std::string\u0026 api_key, const std::string\u0026 secret_key);\\r\\n        \\r\\n        // Validate credentials format\\r\\n        bool validate_credentials() const;\\r\\n        \\r\\n        // Get credentials (returns nullopt if not loaded)\\r\\n        std::optional\u003cCredentials\u003e get_credentials() const;\\r\\n        \\r\\n        // Generate HMAC signature for API requests\\r\\n        std::string generate_signature(const std::string\u0026 query_string, const std::string\u0026 secret) const;\\r\\n        \\r\\n        // Generate timestamp for API requests\\r\\n        std::string get_timestamp() const;\\r\\n        \\r\\n        // Clear credentials from memory\\r\\n        void clear_credentials();\\r\\n        \\r\\n        // Test connection with current credentials\\r\\n        bool test_connection() const;\\r\\n\\r\\n    private:\\r\\n        bool credentials_loaded_;\\r\\n        std::unique_ptr\u003cCredentials\u003e credentials_;\\r\\n        \\r\\n        // Helper methods\\r\\n        bool is_valid_api_key(const std::string\u0026 key) const;\\r\\n        bool is_valid_secret(const std::string\u0026 secret) const;\\r\\n        std::string read_from_env(const std::string\u0026 var_name) const;\\r\\n    };\\r\\n}\\r\\n"
                  },
                  {
                      "size":  466,
                      "relativePath":  "include\\hft\\command.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 14:02:00",
                      "directory":  "include\\hft",
                      "fileName":  "command.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \\\"types.h\\\"\\r\\n#include \u003ccstdint\u003e\\r\\n#include \u003cstring\u003e\\r\\n#include \u003cvector\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    enum class CommandType { MARKET_DATA };\\r\\n\\r\\n    struct Level {\\r\\n        Price price;\\r\\n        Quantity quantity;\\r\\n    };\\r\\n\\r\\n    // Padded to a cache line to prevent false sharing\\r\\n    struct alignas(64) Command {\\r\\n        CommandType type;\\r\\n        uint64_t timestamp_ns;\\r\\n        std::vector\u003cLevel\u003e bids;\\r\\n        std::vector\u003cLevel\u003e asks;\\r\\n    };\\r\\n}\\r\\n"
                  },
                  {
                      "size":  478,
                      "relativePath":  "include\\hft\\common.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 13:47:25",
                      "directory":  "include\\hft",
                      "fileName":  "common.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \u003ccstdint\u003e\\r\\n#include \u003cstring\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    // Legacy types for backward compatibility\\r\\n    using LegacyPrice = int64_t;\\r\\n    using LegacyQuantity = uint64_t;\\r\\n    using OrderID = uint64_t;\\r\\n\\r\\n    // Convert floating point price to a fixed-point integer\\r\\n    inline LegacyPrice price_to_int(double p) { return static_cast\u003cLegacyPrice\u003e(p * 100.0); }\\r\\n    inline double price_to_double(LegacyPrice p) { return static_cast\u003cdouble\u003e(p) / 100.0; }\\r\\n}\\r\\n"
                  },
                  {
                      "size":  626,
                      "relativePath":  "include\\hft\\matching_engine.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-09 21:27:21",
                      "directory":  "include\\hft",
                      "fileName":  "matching_engine.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \u003catomic\u003e\\r\\n#include \u003cthread\u003e\\r\\n#include \u003cboost/lockfree/queue.hpp\u003e\\r\\n#include \\\"command.h\\\"\\r\\n#include \\\"order_book.h\\\"\\r\\n\\r\\nnamespace hft {\\r\\n    class MatchingEngine {\\r\\n    public:\\r\\n        MatchingEngine(int book_depth);\\r\\n        ~MatchingEngine();\\r\\n\\r\\n        bool post_command(Command\u0026\u0026 cmd);\\r\\n        void run();\\r\\n        void stop();\\r\\n\\r\\n    private:\\r\\n        void writer_thread_func();\\r\\n\\r\\n        boost::lockfree::queue\u003cCommand*\u003e command_queue_{1024 * 64};\\r\\n        OrderBook order_book_;\\r\\n        int book_depth_;\\r\\n\\r\\n        std::atomic\u003cbool\u003e running_{false};\\r\\n        std::thread writer_thread_;\\r\\n    };\\r\\n}"
                  },
                  {
                      "size":  381,
                      "relativePath":  "include\\hft\\order_book.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "include\\hft",
                      "fileName":  "order_book.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \\\"command.h\\\"\\r\\n#include \u003cmap\u003e\\r\\n#include \u003cvector\u003e\\r\\n#include \u003cstring\u003e\\r\\n#include \u003ciostream\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    class OrderBook {\\r\\n    public:\\r\\n        void update(const Command\u0026 cmd);\\r\\n        void print_book(int depth) const;\\r\\n\\r\\n    private:\\r\\n        std::map\u003cPrice, Quantity, std::greater\u003cPrice\u003e\u003e bids_;\\r\\n        std::map\u003cPrice, Quantity\u003e asks_;\\r\\n    };\\r\\n}"
                  },
                  {
                      "size":  3377,
                      "relativePath":  "include\\hft\\trading_client.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 13:43:47",
                      "directory":  "include\\hft",
                      "fileName":  "trading_client.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \\\"types.h\\\"\\r\\n#include \\\"auth_manager.h\\\"\\r\\n#include \u003cvector\u003e\\r\\n#include \u003cunordered_map\u003e\\r\\n#include \u003cfunctional\u003e\\r\\n#include \u003cfuture\u003e\\r\\n#include \u003cmemory\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    class TradingClient {\\r\\n    public:\\r\\n        using OrderCallback = std::function\u003cvoid(const Order\u0026)\u003e;\\r\\n        using TradeCallback = std::function\u003cvoid(const Trade\u0026)\u003e;\\r\\n        using ErrorCallback = std::function\u003cvoid(const std::string\u0026)\u003e;\\r\\n\\r\\n        explicit TradingClient(std::shared_ptr\u003cAuthManager\u003e auth_manager);\\r\\n        ~TradingClient();\\r\\n\\r\\n        // Connection management\\r\\n        bool connect();\\r\\n        void disconnect();\\r\\n        bool is_connected() const;\\r\\n\\r\\n        // Order management\\r\\n        std::future\u003cOrderId\u003e place_order(const Symbol\u0026 symbol, Side side, OrderType type, \\r\\n                                       Price price, Quantity quantity, TimeInForce tif = TimeInForce::GTC);\\r\\n        std::future\u003cbool\u003e cancel_order(const OrderId\u0026 order_id);\\r\\n        std::future\u003cbool\u003e cancel_all_orders(const Symbol\u0026 symbol = \\\"\\\");\\r\\n        \\r\\n        // Account information\\r\\n        std::future\u003cstd::vector\u003cOrder\u003e\u003e get_open_orders(const Symbol\u0026 symbol = \\\"\\\");\\r\\n        std::future\u003cstd::vector\u003cTrade\u003e\u003e get_trade_history(const Symbol\u0026 symbol = \\\"\\\", int limit = 100);\\r\\n        std::future\u003cdouble\u003e get_account_balance(const std::string\u0026 asset = \\\"USDT\\\");\\r\\n        \\r\\n        // Order status queries\\r\\n        std::future\u003cOrder\u003e get_order_status(const OrderId\u0026 order_id);\\r\\n        \\r\\n        // Callbacks for real-time updates\\r\\n        void set_order_callback(OrderCallback callback);\\r\\n        void set_trade_callback(TradeCallback callback);\\r\\n        void set_error_callback(ErrorCallback callback);\\r\\n        \\r\\n        // Risk management\\r\\n        void set_max_position_size(const Symbol\u0026 symbol, Quantity max_size);\\r\\n        void set_max_order_value(double max_value);\\r\\n        bool validate_order(const Symbol\u0026 symbol, Side side, Price price, Quantity quantity) const;\\r\\n        \\r\\n        // Market data requests\\r\\n        std::future\u003cdouble\u003e get_current_price(const Symbol\u0026 symbol);\\r\\n        std::future\u003cstd::pair\u003cPrice, Price\u003e\u003e get_bid_ask_spread(const Symbol\u0026 symbol);\\r\\n\\r\\n    private:\\r\\n        std::shared_ptr\u003cAuthManager\u003e auth_manager_;\\r\\n        bool connected_;\\r\\n        \\r\\n        // Risk management settings\\r\\n        std::unordered_map\u003cSymbol, Quantity\u003e max_position_sizes_;\\r\\n        double max_order_value_;\\r\\n        \\r\\n        // Callbacks\\r\\n        OrderCallback order_callback_;\\r\\n        TradeCallback trade_callback_;\\r\\n        ErrorCallback error_callback_;\\r\\n        \\r\\n        // Internal order tracking\\r\\n        std::unordered_map\u003cOrderId, Order\u003e active_orders_;\\r\\n        \\r\\n        // HTTP client for REST API calls\\r\\n        std::string make_authenticated_request(const std::string\u0026 endpoint, const std::string\u0026 method, \\r\\n                                              const std::string\u0026 params = \\\"\\\");\\r\\n        \\r\\n        // Helper methods\\r\\n        OrderId generate_order_id();\\r\\n        std::string get_current_timestamp();\\r\\n        bool check_connection();\\r\\n        void handle_error(const std::string\u0026 error_message);\\r\\n        \\r\\n        // Order validation\\r\\n        bool validate_price(Price price) const;\\r\\n        bool validate_quantity(Quantity quantity) const;\\r\\n        bool check_risk_limits(const Symbol\u0026 symbol, Side side, Price price, Quantity quantity) const;\\r\\n    };\\r\\n}\\r\\n"
                  },
                  {
                      "size":  1208,
                      "relativePath":  "include\\hft\\types.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 13:43:07",
                      "directory":  "include\\hft",
                      "fileName":  "types.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \u003cstring\u003e\\r\\n#include \u003ccstdint\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    using Price = double;\\r\\n    using Quantity = double;\\r\\n    using OrderId = std::string;\\r\\n    using Symbol = std::string;\\r\\n    using Timestamp = uint64_t;\\r\\n\\r\\n    enum class Side {\\r\\n        BUY,\\r\\n        SELL\\r\\n    };\\r\\n\\r\\n    enum class OrderType {\\r\\n        MARKET,\\r\\n        LIMIT,\\r\\n        STOP_LIMIT\\r\\n    };\\r\\n\\r\\n    enum class OrderStatus {\\r\\n        NEW,\\r\\n        PARTIALLY_FILLED,\\r\\n        FILLED,\\r\\n        CANCELED,\\r\\n        REJECTED,\\r\\n        EXPIRED\\r\\n    };\\r\\n\\r\\n    enum class TimeInForce {\\r\\n        GTC,  // Good Till Canceled\\r\\n        IOC,  // Immediate or Cancel\\r\\n        FOK   // Fill or Kill\\r\\n    };\\r\\n\\r\\n    struct Order {\\r\\n        OrderId id;\\r\\n        Symbol symbol;\\r\\n        Side side;\\r\\n        OrderType type;\\r\\n        Price price;\\r\\n        Quantity quantity;\\r\\n        Quantity filled_quantity = 0.0;\\r\\n        OrderStatus status = OrderStatus::NEW;\\r\\n        TimeInForce time_in_force = TimeInForce::GTC;\\r\\n        Timestamp timestamp;\\r\\n    };\\r\\n\\r\\n    struct Trade {\\r\\n        OrderId order_id;\\r\\n        Symbol symbol;\\r\\n        Side side;\\r\\n        Price price;\\r\\n        Quantity quantity;\\r\\n        Timestamp timestamp;\\r\\n    };\\r\\n}\\r\\n"
                  },
                  {
                      "size":  3689,
                      "relativePath":  "include\\hft\\ui_manager.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-10 13:44:12",
                      "directory":  "include\\hft",
                      "fileName":  "ui_manager.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \\\"types.h\\\"\\r\\n#include \\\"order_book.h\\\"\\r\\n#include \u003cvector\u003e\\r\\n#include \u003cstring\u003e\\r\\n#include \u003cmemory\u003e\\r\\n#include \u003cfunctional\u003e\\r\\n\\r\\nnamespace hft {\\r\\n    enum class UIMode {\\r\\n        LOGIN,\\r\\n        MAIN_MENU,\\r\\n        ORDER_BOOK_VIEW,\\r\\n        ORDER_MANAGEMENT,\\r\\n        ACCOUNT_INFO,\\r\\n        SETTINGS\\r\\n    };\\r\\n\\r\\n    class UIManager {\\r\\n    public:\\r\\n        using LoginCallback = std::function\u003cbool(const std::string\u0026, const std::string\u0026)\u003e;\\r\\n        using OrderCallback = std::function\u003cvoid(const Symbol\u0026, Side, OrderType, Price, Quantity)\u003e;\\r\\n        using CancelCallback = std::function\u003cvoid(const OrderId\u0026)\u003e;\\r\\n\\r\\n        UIManager();\\r\\n        ~UIManager();\\r\\n\\r\\n        // UI lifecycle\\r\\n        bool initialize();\\r\\n        void cleanup();\\r\\n        void run();\\r\\n        void stop();\\r\\n\\r\\n        // Mode management\\r\\n        void set_mode(UIMode mode);\\r\\n        UIMode get_current_mode() const;\\r\\n\\r\\n        // Display methods\\r\\n        void display_login_screen();\\r\\n        void display_main_menu();\\r\\n        void display_order_book(const OrderBook\u0026 order_book, int depth = 10);\\r\\n        void display_order_management(const std::vector\u003cOrder\u003e\u0026 orders);\\r\\n        void display_account_info(double balance, const std::vector\u003cTrade\u003e\u0026 recent_trades);\\r\\n        void display_error(const std::string\u0026 message);\\r\\n        void display_status(const std::string\u0026 message);\\r\\n\\r\\n        // Input handling\\r\\n        std::pair\u003cstd::string, std::string\u003e get_login_credentials();\\r\\n        int get_menu_choice(const std::vector\u003cstd::string\u003e\u0026 options);\\r\\n        Order get_order_input(const Symbol\u0026 symbol);\\r\\n        std::string get_cancel_order_id();\\r\\n\\r\\n        // Callbacks\\r\\n        void set_login_callback(LoginCallback callback);\\r\\n        void set_order_callback(OrderCallback callback);\\r\\n        void set_cancel_callback(CancelCallback callback);\\r\\n\\r\\n        // UI updates\\r\\n        void update_connection_status(bool connected);\\r\\n        void update_order_book(const OrderBook\u0026 order_book);\\r\\n        void update_orders(const std::vector\u003cOrder\u003e\u0026 orders);\\r\\n        void update_balance(double balance);\\r\\n\\r\\n        // Utility methods\\r\\n        void clear_screen();\\r\\n        void print_header(const std::string\u0026 title);\\r\\n        void print_separator();\\r\\n        void wait_for_key();\\r\\n\\r\\n    private:\\r\\n        UIMode current_mode_;\\r\\n        bool running_;\\r\\n        bool initialized_;\\r\\n\\r\\n        // Callbacks\\r\\n        LoginCallback login_callback_;\\r\\n        OrderCallback order_callback_;\\r\\n        CancelCallback cancel_callback_;\\r\\n\\r\\n        // Display state\\r\\n        bool connection_status_;\\r\\n        std::string last_error_;\\r\\n        std::string last_status_;\\r\\n\\r\\n        // Input/output helpers\\r\\n        std::string get_input(const std::string\u0026 prompt);\\r\\n        double get_numeric_input(const std::string\u0026 prompt);\\r\\n        char get_char_input();\\r\\n        void print_colored(const std::string\u0026 text, const std::string\u0026 color);\\r\\n        \\r\\n        // Screen drawing\\r\\n        void draw_border();\\r\\n        void draw_order_book_table(const OrderBook\u0026 order_book, int depth);\\r\\n        void draw_order_table(const std::vector\u003cOrder\u003e\u0026 orders);\\r\\n        void draw_menu(const std::vector\u003cstd::string\u003e\u0026 options);\\r\\n        \\r\\n        // Validation\\r\\n        bool validate_price_input(const std::string\u0026 input);\\r\\n        bool validate_quantity_input(const std::string\u0026 input);\\r\\n        \\r\\n        // Color codes for terminal output\\r\\n        static const std::string RESET;\\r\\n        static const std::string RED;\\r\\n        static const std::string GREEN;\\r\\n        static const std::string YELLOW;\\r\\n        static const std::string BLUE;\\r\\n        static const std::string CYAN;\\r\\n        static const std::string WHITE;\\r\\n    };\\r\\n}\\r\\n"
                  },
                  {
                      "size":  677,
                      "relativePath":  "include\\hft\\websocket_client.h",
                      "extension":  ".h",
                      "lastModified":  "2025-07-09 22:08:12",
                      "directory":  "include\\hft",
                      "fileName":  "websocket_client.h",
                      "type":  "header",
                      "content":  "#pragma once\\r\\n#include \\\"matching_engine.h\\\"\\r\\n#include \u003cwebsocketpp/client.hpp\u003e\\r\\n#include \u003cwebsocketpp/config/asio_client.hpp\u003e\\r\\n#include \u003cstring\u003e\\r\\n#include \u003cmemory\u003e\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\n    // Use the standard, default client config\\r\\n    using client = websocketpp::client\u003cwebsocketpp::config::asio_tls_client\u003e;\\r\\n\\r\\n    class WebsocketClient {\\r\\n    public:\\r\\n        WebsocketClient(MatchingEngine\u0026 engine, std::string symbol);\\r\\n        void run();\\r\\n\\r\\n    private:\\r\\n        void on_message(websocketpp::connection_hdl hdl, client::message_ptr msg);\\r\\n\\r\\n        MatchingEngine\u0026 engine_;\\r\\n        client ws_client_;\\r\\n        std::string uri_;\\r\\n        std::string symbol_;\\r\\n    };\\r\\n}"
                  },
                  {
                      "size":  6634,
                      "relativePath":  "scripts\\backup.ps1",
                      "extension":  ".ps1",
                      "lastModified":  "2025-07-10 14:57:00",
                      "directory":  "scripts",
                      "fileName":  "backup.ps1",
                      "type":  "script",
                      "content":  "# HFT Engine Backup Script\\r\\n# Creates a JSON-formatted backup file (.bkpf) containing all relevant project files\\r\\n\\r\\nparam(\\r\\n    [string]$OutputPath = \\\"hft-build-backup\\\",\\r\\n    [string]$ProjectName = \\\"hft_engine\\\"\\r\\n)\\r\\n\\r\\n# Get the project root directory\\r\\n$ProjectRoot = Split-Path -Parent $PSScriptRoot\\r\\n$BackupDir = Join-Path $ProjectRoot $OutputPath\\r\\n$BackupFileName = \\\"${ProjectName}_backup_$(Get-Date -Format \u0027yyyyMMdd_HHmmss\u0027).bkpf\\\"\\r\\n$BackupPath = Join-Path $BackupDir $BackupFileName\\r\\n\\r\\nWrite-Host \\\"Creating backup for project: $ProjectName\\\" -ForegroundColor Green\\r\\nWrite-Host \\\"Project root: $ProjectRoot\\\" -ForegroundColor Yellow\\r\\nWrite-Host \\\"Backup directory: $BackupDir\\\" -ForegroundColor Yellow\\r\\nWrite-Host \\\"Backup file: $BackupFileName\\\" -ForegroundColor Yellow\\r\\n\\r\\n# Create backup directory if it doesn\u0027t exist\\r\\nif (-not (Test-Path $BackupDir)) {\\r\\n    New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null\\r\\n    Write-Host \\\"Created backup directory: $BackupDir\\\" -ForegroundColor Green\\r\\n}\\r\\n\\r\\n# Define file extensions to include\\r\\n$IncludeExtensions = @(\\r\\n    \u0027.cpp\u0027, \u0027.c\u0027, \u0027.cc\u0027, \u0027.cxx\u0027,     # C++ source files\\r\\n    \u0027.h\u0027, \u0027.hpp\u0027, \u0027.hxx\u0027,            # Header files\\r\\n    \u0027.py\u0027, \u0027.pyx\u0027, \u0027.pyi\u0027,           # Python files\\r\\n    \u0027.cmake\u0027, \u0027.txt\u0027,                # CMake files\\r\\n    \u0027.md\u0027, \u0027.rst\u0027,                   # Documentation\\r\\n    \u0027.json\u0027, \u0027.yaml\u0027, \u0027.yml\u0027,        # Configuration files\\r\\n    \u0027.sh\u0027, \u0027.bat\u0027, \u0027.ps1\u0027,           # Scripts\\r\\n    \u0027.gitignore\u0027, \u0027.gitattributes\u0027   # Git files\\r\\n)\\r\\n\\r\\n# Define special files to always include\\r\\n$SpecialFiles = @(\\r\\n    \u0027CMakeLists.txt\u0027,\\r\\n    \u0027README.md\u0027,\\r\\n    \u0027Dockerfile\u0027,\\r\\n    \u0027Makefile\u0027,\\r\\n    \u0027.gitignore\u0027\\r\\n)\\r\\n\\r\\n# Define directories to exclude\\r\\n$ExcludeDirectories = @(\\r\\n    \u0027build\u0027, \u0027Build\u0027, \u0027BUILD\u0027,\\r\\n    \u0027cmake-build-debug\u0027, \u0027cmake-build-release\u0027,\\r\\n    \u0027.git\u0027, \u0027.svn\u0027, \u0027.hg\u0027,\\r\\n    \u0027.idea\u0027, \u0027.vscode\u0027, \u0027.vs\u0027,\\r\\n    \u0027external\u0027, \u0027third_party\u0027, \u0027deps\u0027,\\r\\n    \u0027node_modules\u0027, \u0027__pycache__\u0027,\\r\\n    \u0027.pytest_cache\u0027, \u0027.coverage\u0027,\\r\\n    \u0027dist\u0027, \u0027target\u0027, \u0027out\u0027,\\r\\n    \u0027hft-build-backup\u0027\\r\\n)\\r\\n\\r\\n# Function to determine file type based on extension\\r\\nfunction Get-FileType {\\r\\n    param($Extension)\\r\\n    switch ($Extension) {\\r\\n        { $_ -in @(\u0027.cpp\u0027, \u0027.c\u0027, \u0027.cc\u0027, \u0027.cxx\u0027) } { return \u0027source\u0027 }\\r\\n        { $_ -in @(\u0027.h\u0027, \u0027.hpp\u0027, \u0027.hxx\u0027) } { return \u0027header\u0027 }\\r\\n        { $_ -in @(\u0027.py\u0027, \u0027.pyx\u0027, \u0027.pyi\u0027) } { return \u0027python\u0027 }\\r\\n        { $_ -in @(\u0027.cmake\u0027, \u0027.txt\u0027) } { return \u0027cmake\u0027 }\\r\\n        { $_ -in @(\u0027.md\u0027, \u0027.rst\u0027) } { return \u0027documentation\u0027 }\\r\\n        { $_ -in @(\u0027.json\u0027, \u0027.yaml\u0027, \u0027.yml\u0027) } { return \u0027configuration\u0027 }\\r\\n        { $_ -in @(\u0027.sh\u0027, \u0027.bat\u0027, \u0027.ps1\u0027) } { return \u0027script\u0027 }\\r\\n        { $_ -in @(\u0027.gitignore\u0027, \u0027.gitattributes\u0027) } { return \u0027git\u0027 }\\r\\n        { $_ -eq \u0027\u0027 } { return \u0027special\u0027 }\\r\\n        default { return \u0027other\u0027 }\\r\\n    }\\r\\n}\\r\\n\\r\\n# Function to check if directory should be excluded\\r\\nfunction Should-ExcludeDirectory {\\r\\n    param($DirectoryPath)\\r\\n    foreach ($ExcludeDir in $ExcludeDirectories) {\\r\\n        if ($DirectoryPath -like \\\"*$ExcludeDir*\\\") {\\r\\n            return $true\\r\\n        }\\r\\n    }\\r\\n    return $false\\r\\n}\\r\\n\\r\\n# Function to escape JSON strings\\r\\nfunction Escape-JsonString {\\r\\n    param($InputString)\\r\\n    if ($null -eq $InputString) { return \\\"\\\" }\\r\\n    $InputString = $InputString -replace \u0027\\\\\\\\\\\\\\\\\u0027, \u0027\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\u0027\\r\\n    $InputString = $InputString -replace \u0027\\\"\u0027, \u0027\\\\\\\\\\\"\u0027\\r\\n    $InputString = $InputString -replace \\\"`n\\\", \u0027\\\\\\\\n\u0027\\r\\n    $InputString = $InputString -replace \\\"`r\\\", \u0027\\\\\\\\r\u0027\\r\\n    $InputString = $InputString -replace \\\"`t\\\", \u0027\\\\\\\\t\u0027\\r\\n    return $InputString\\r\\n}\\r\\n\\r\\n# Collect all relevant files\\r\\n$Files = @()\\r\\n$FileCount = 0\\r\\n\\r\\nWrite-Host \\\"Scanning for files...\\\" -ForegroundColor Green\\r\\n\\r\\nGet-ChildItem -Path $ProjectRoot -Recurse -File | ForEach-Object {\\r\\n    $File = $_\\r\\n    $RelativePath = $File.FullName.Substring($ProjectRoot.Length + 1)\\r\\n    \\r\\n    # Check if file is in an excluded directory\\r\\n    if (Should-ExcludeDirectory $RelativePath) {\\r\\n        return\\r\\n    }\\r\\n    \\r\\n    # Check if file extension is included or if it\u0027s a special file\\r\\n    $Extension = $File.Extension.ToLower()\\r\\n    $IsIncluded = $IncludeExtensions -contains $Extension -or $SpecialFiles -contains $File.Name\\r\\n    \\r\\n    if ($IsIncluded) {\\r\\n        try {\\r\\n            $Content = Get-Content -Path $File.FullName -Raw -ErrorAction Stop\\r\\n            $EscapedContent = Escape-JsonString $Content\\r\\n            \\r\\n            $Directory = Split-Path -Path $RelativePath -Parent\\r\\n            if ([string]::IsNullOrEmpty($Directory)) {\\r\\n                $Directory = \\\"\\\"\\r\\n            }\\r\\n            \\r\\n            $FileInfo = @{\\r\\n                directory = $Directory\\r\\n                fileName = $File.Name\\r\\n                extension = $Extension\\r\\n                type = Get-FileType $Extension\\r\\n                relativePath = $RelativePath\\r\\n                size = $File.Length\\r\\n                lastModified = $File.LastWriteTime.ToString(\u0027yyyy-MM-dd HH:mm:ss\u0027)\\r\\n                content = $EscapedContent\\r\\n            }\\r\\n            $Files += $FileInfo\\r\\n            $FileCount++\\r\\n            Write-Host \\\"  Added: $RelativePath\\\" -ForegroundColor Green\\r\\n        }\\r\\n        catch {\\r\\n            Write-Host \\\"  Skipped: $RelativePath (binary or inaccessible)\\\" -ForegroundColor Yellow\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n# Create backup object\\r\\n$BackupData = @{\\r\\n    metadata = @{\\r\\n        projectName = $ProjectName\\r\\n        backupDate = Get-Date -Format \u0027yyyy-MM-dd HH:mm:ss\u0027\\r\\n        projectRoot = $ProjectRoot\\r\\n        fileCount = $FileCount\\r\\n        backupVersion = \\\"1.0\\\"\\r\\n        generatedBy = \\\"HFT Engine Backup Script (PowerShell)\\\"\\r\\n    }\\r\\n    files = $Files\\r\\n}\\r\\n\\r\\n# Convert to JSON and save\\r\\nWrite-Host \\\"Creating backup file...\\\" -ForegroundColor Green\\r\\ntry {\\r\\n    $JsonData = $BackupData | ConvertTo-Json -Depth 10 -Compress:$false\\r\\n    $JsonData | Out-File -FilePath $BackupPath -Encoding UTF8\\r\\n    \\r\\n    $BackupSize = (Get-Item $BackupPath).Length\\r\\n    Write-Host \\\"Backup created successfully!\\\" -ForegroundColor Green\\r\\n    Write-Host \\\"File: $BackupPath\\\" -ForegroundColor Yellow\\r\\n    Write-Host \\\"Size: $([math]::Round($BackupSize / 1MB, 2)) MB\\\" -ForegroundColor Yellow\\r\\n    Write-Host \\\"Files included: $FileCount\\\" -ForegroundColor Yellow\\r\\n}\\r\\ncatch {\\r\\n    Write-Host \\\"Error creating backup: $($_.Exception.Message)\\\" -ForegroundColor Red\\r\\n    exit 1\\r\\n}\\r\\n\\r\\n# Display summary by file type\\r\\nWrite-Host \\\"`nFile type summary:\\\" -ForegroundColor Green\\r\\n$Files | Group-Object -Property type | Sort-Object Name | ForEach-Object {\\r\\n    Write-Host \\\"  $($_.Name): $($_.Count) files\\\" -ForegroundColor Cyan\\r\\n}\\r\\n\\r\\nWrite-Host \\\"`nBackup completed successfully!\\\" -ForegroundColor Green\\r\\nWrite-Host \\\"Backup saved to: $BackupDir\\\" -ForegroundColor Yellow\\r\\n"
                  },
                  {
                      "size":  6842,
                      "relativePath":  "scripts\\backup.sh",
                      "extension":  ".sh",
                      "lastModified":  "2025-07-10 14:54:04",
                      "directory":  "scripts",
                      "fileName":  "backup.sh",
                      "type":  "script",
                      "content":  "#!/bin/bash\\r\\n\\r\\n# HFT Engine Backup Script\\r\\n# Creates a JSON-formatted backup file (.bkpf) containing all relevant project files\\r\\n# Saves backups in hft-build-backup folder\\r\\n\\r\\nPROJECT_NAME=\\\"hft_engine\\\"\\r\\nSCRIPT_DIR=\\\"$(cd \\\"$(dirname \\\"${BASH_SOURCE[0]}\\\")\\\" \u0026\u0026 pwd)\\\"\\r\\nPROJECT_ROOT=\\\"$(dirname \\\"$SCRIPT_DIR\\\")\\\"\\r\\nBACKUP_DIR=\\\"$PROJECT_ROOT/hft-build-backup\\\"\\r\\nBACKUP_FILENAME=\\\"${PROJECT_NAME}_backup_$(date +%Y%m%d_%H%M%S).bkpf\\\"\\r\\nBACKUP_PATH=\\\"$BACKUP_DIR/$BACKUP_FILENAME\\\"\\r\\n\\r\\necho \\\"Creating backup for project: $PROJECT_NAME\\\"\\r\\necho \\\"Project root: $PROJECT_ROOT\\\"\\r\\necho \\\"Backup directory: $BACKUP_DIR\\\"\\r\\necho \\\"Backup file: $BACKUP_FILENAME\\\"\\r\\n\\r\\n# Create backup directory if it doesn\u0027t exist\\r\\nmkdir -p \\\"$BACKUP_DIR\\\"\\r\\n\\r\\n# Define file extensions and patterns to include\\r\\nINCLUDE_PATTERNS=(\\r\\n    \\\"*.cpp\\\" \\\"*.c\\\" \\\"*.cc\\\" \\\"*.cxx\\\"     # C++ source files\\r\\n    \\\"*.h\\\" \\\"*.hpp\\\" \\\"*.hxx\\\"            # Header files\\r\\n    \\\"*.py\\\" \\\"*.pyx\\\" \\\"*.pyi\\\"           # Python files\\r\\n    \\\"*.cmake\\\" \\\"*.txt\\\"                # CMake files\\r\\n    \\\"*.md\\\" \\\"*.rst\\\"                   # Documentation\\r\\n    \\\"*.json\\\" \\\"*.yaml\\\" \\\"*.yml\\\"        # Configuration files\\r\\n    \\\"*.sh\\\" \\\"*.bat\\\" \\\"*.ps1\\\"           # Scripts\\r\\n    \\\"*.gitignore\\\" \\\"*.gitattributes\\\"  # Git files\\r\\n    \\\"CMakeLists.txt\\\"                 # CMake main file\\r\\n    \\\"README.md\\\"                      # README\\r\\n    \\\"Dockerfile\\\"                     # Docker file\\r\\n    \\\"Makefile\\\"                       # Make file\\r\\n    \\\"*.toml\\\" \\\"*.ini\\\" \\\"*.cfg\\\"         # Config files\\r\\n)\\r\\n\\r\\n# Define directories to exclude\\r\\nEXCLUDE_DIRECTORIES=(\\r\\n    \\\"build\\\" \\\"Build\\\" \\\"BUILD\\\"\\r\\n    \\\"cmake-build-debug\\\" \\\"cmake-build-release\\\"\\r\\n    \\\".git\\\" \\\".svn\\\" \\\".hg\\\"\\r\\n    \\\".idea\\\" \\\".vscode\\\" \\\".vs\\\"\\r\\n    \\\"external\\\" \\\"third_party\\\" \\\"deps\\\"\\r\\n    \\\"node_modules\\\" \\\"__pycache__\\\"\\r\\n    \\\".pytest_cache\\\" \\\".coverage\\\"\\r\\n    \\\"dist\\\" \\\"target\\\" \\\"out\\\"\\r\\n    \\\"hft-build-backup\\\"\\r\\n)\\r\\n\\r\\n# Function to determine file type based on extension\\r\\nget_file_type() {\\r\\n    local ext=\\\"$1\\\"\\r\\n    case \\\"$ext\\\" in\\r\\n        \\\".cpp\\\"|\\\".c\\\"|\\\".cc\\\"|\\\".cxx\\\") echo \\\"source\\\" ;;\\r\\n        \\\".h\\\"|\\\".hpp\\\"|\\\".hxx\\\") echo \\\"header\\\" ;;\\r\\n        \\\".py\\\"|\\\".pyx\\\"|\\\".pyi\\\") echo \\\"python\\\" ;;\\r\\n        \\\".cmake\\\"|\\\".txt\\\") echo \\\"cmake\\\" ;;\\r\\n        \\\".md\\\"|\\\".rst\\\") echo \\\"documentation\\\" ;;\\r\\n        \\\".json\\\"|\\\".yaml\\\"|\\\".yml\\\"|\\\".toml\\\"|\\\".ini\\\"|\\\".cfg\\\") echo \\\"configuration\\\" ;;\\r\\n        \\\".sh\\\"|\\\".bat\\\"|\\\".ps1\\\") echo \\\"script\\\" ;;\\r\\n        \\\".gitignore\\\"|\\\".gitattributes\\\") echo \\\"git\\\" ;;\\r\\n        \\\"\\\") echo \\\"special\\\" ;;  # For files without extension\\r\\n        *) echo \\\"other\\\" ;;\\r\\n    esac\\r\\n}\\r\\n\\r\\n# Function to check if directory should be excluded\\r\\nshould_exclude_directory() {\\r\\n    local path=\\\"$1\\\"\\r\\n    for exclude_dir in \\\"${EXCLUDE_DIRECTORIES[@]}\\\"; do\\r\\n        if [[ \\\"$path\\\" == *\\\"/$exclude_dir/\\\"* ]] || [[ \\\"$path\\\" == \\\"$exclude_dir/\\\"* ]] || [[ \\\"$path\\\" == *\\\"/$exclude_dir\\\" ]]; then\\r\\n            return 0\\r\\n        fi\\r\\n    done\\r\\n    return 1\\r\\n}\\r\\n\\r\\n# Function to escape JSON strings\\r\\nescape_json() {\\r\\n    local str=\\\"$1\\\"\\r\\n    # Replace backslashes first, then quotes, then newlines/tabs/carriage returns\\r\\n    str=\\\"${str//\\\\\\\\\\\\\\\\/\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\}\\\"\\r\\n    str=\\\"${str//\\\\\\\\\\\"/\\\\\\\\\\\\\\\\\\\\\\\\\\\"}\\\"\\r\\n    str=\\\"${str//$\u0027\\\\\\\\n\u0027/\\\\\\\\\\\\\\\\n}\\\"\\r\\n    str=\\\"${str//$\u0027\\\\\\\\r\u0027/\\\\\\\\\\\\\\\\r}\\\"\\r\\n    str=\\\"${str//$\u0027\\\\\\\\t\u0027/\\\\\\\\\\\\\\\\t}\\\"\\r\\n    echo \\\"$str\\\"\\r\\n}\\r\\n\\r\\necho \\\"Scanning for files...\\\"\\r\\n\\r\\n# Start building the JSON backup file\\r\\n{\\r\\n    echo \\\"{\\\"\\r\\n    echo \\\"  \\\\\\\\\\\"metadata\\\\\\\\\\\": {\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"projectName\\\\\\\\\\\": \\\\\\\\\\\"$PROJECT_NAME\\\\\\\\\\\",\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"backupDate\\\\\\\\\\\": \\\\\\\\\\\"$(date \u0027+%Y-%m-%d %H:%M:%S\u0027)\\\\\\\\\\\",\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"projectRoot\\\\\\\\\\\": \\\\\\\\\\\"$PROJECT_ROOT\\\\\\\\\\\",\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"backupVersion\\\\\\\\\\\": \\\\\\\\\\\"1.0\\\\\\\\\\\",\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"generatedBy\\\\\\\\\\\": \\\\\\\\\\\"HFT Engine Backup Script (Bash)\\\\\\\\\\\",\\\"\\r\\n    echo \\\"    \\\\\\\\\\\"fileCount\\\\\\\\\\\": 0\\\"\\r\\n    echo \\\"  },\\\"\\r\\n    echo \\\"  \\\\\\\\\\\"files\\\\\\\\\\\": [\\\"\\r\\n    \\r\\n    first_file=true\\r\\n    file_count=0\\r\\n    \\r\\n    # Find all files matching our patterns\\r\\n    for pattern in \\\"${INCLUDE_PATTERNS[@]}\\\"; do\\r\\n        find \\\"$PROJECT_ROOT\\\" -name \\\"$pattern\\\" -type f 2\u003e/dev/null | while read -r file; do\\r\\n            # Skip if file doesn\u0027t exist or is not readable\\r\\n            if [[ ! -r \\\"$file\\\" ]]; then\\r\\n                continue\\r\\n            fi\\r\\n            \\r\\n            relative_path=\\\"${file#$PROJECT_ROOT/}\\\"\\r\\n            \\r\\n            # Skip if in excluded directory\\r\\n            if should_exclude_directory \\\"$relative_path\\\"; then\\r\\n                continue\\r\\n            fi\\r\\n            \\r\\n            filename=$(basename \\\"$file\\\")\\r\\n            extension=\\\"${filename##*.}\\\"\\r\\n            if [[ \\\"$filename\\\" == \\\"$extension\\\" ]]; then\\r\\n                extension=\\\"\\\"\\r\\n            else\\r\\n                extension=\\\".$extension\\\"\\r\\n            fi\\r\\n            \\r\\n            # Get file metadata\\r\\n            directory=$(dirname \\\"$relative_path\\\")\\r\\n            if [[ \\\"$directory\\\" == \\\".\\\" ]]; then\\r\\n                directory=\\\"\\\"\\r\\n            fi\\r\\n            \\r\\n            file_size=$(stat -c%s \\\"$file\\\" 2\u003e/dev/null || echo \\\"0\\\")\\r\\n            last_modified=$(stat -c%y \\\"$file\\\" 2\u003e/dev/null | cut -d. -f1 || echo \\\"\\\")\\r\\n            file_type=$(get_file_type \\\"$extension\\\")\\r\\n            \\r\\n            # Read and escape file content\\r\\n            content=$(cat \\\"$file\\\" 2\u003e/dev/null || echo \\\"\\\")\\r\\n            escaped_content=$(escape_json \\\"$content\\\")\\r\\n            \\r\\n            # Add comma if not first file\\r\\n            if [[ \\\"$first_file\\\" != true ]]; then\\r\\n                echo \\\",\\\"\\r\\n            fi\\r\\n            first_file=false\\r\\n            \\r\\n            # Add file entry to JSON\\r\\n            echo \\\"    {\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"directory\\\\\\\\\\\": \\\\\\\\\\\"$directory\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"fileName\\\\\\\\\\\": \\\\\\\\\\\"$filename\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"extension\\\\\\\\\\\": \\\\\\\\\\\"$extension\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"type\\\\\\\\\\\": \\\\\\\\\\\"$file_type\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"relativePath\\\\\\\\\\\": \\\\\\\\\\\"$relative_path\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"size\\\\\\\\\\\": $file_size,\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"lastModified\\\\\\\\\\\": \\\\\\\\\\\"$last_modified\\\\\\\\\\\",\\\"\\r\\n            echo \\\"      \\\\\\\\\\\"content\\\\\\\\\\\": \\\\\\\\\\\"$escaped_content\\\\\\\\\\\"\\\"\\r\\n            echo -n \\\"    }\\\"\\r\\n            \\r\\n            ((file_count++))\\r\\n            echo \\\"  Added: $relative_path\\\" \u003e\u00262\\r\\n        done\\r\\n    done\\r\\n    \\r\\n    echo \\\"\\\"\\r\\n    echo \\\"  ]\\\"\\r\\n    echo \\\"}\\\"\\r\\n} \u003e \\\"$BACKUP_PATH\\\"\\r\\n\\r\\n# Update file count in metadata\\r\\ntemp_file=$(mktemp)\\r\\nfile_count=$(grep -c \\\"relativePath\\\" \\\"$BACKUP_PATH\\\" 2\u003e/dev/null || echo \\\"0\\\")\\r\\nsed \\\"s/\\\\\\\\\\\"fileCount\\\\\\\\\\\": 0/\\\\\\\\\\\"fileCount\\\\\\\\\\\": $file_count/\\\" \\\"$BACKUP_PATH\\\" \u003e \\\"$temp_file\\\"\\r\\nmv \\\"$temp_file\\\" \\\"$BACKUP_PATH\\\"\\r\\n\\r\\necho \\\"Backup created successfully!\\\"\\r\\necho \\\"File: $BACKUP_PATH\\\"\\r\\nbackup_size=$(stat -c%s \\\"$BACKUP_PATH\\\" 2\u003e/dev/null || echo \\\"0\\\")\\r\\nbackup_size_mb=$(echo \\\"scale=2; $backup_size / 1024 / 1024\\\" | bc -l 2\u003e/dev/null || echo \\\"0\\\")\\r\\necho \\\"Size: ${backup_size_mb} MB\\\"\\r\\necho \\\"Files included: $file_count\\\"\\r\\n\\r\\n# Display file type summary\\r\\necho \\\"\\\"\\r\\necho \\\"File type summary:\\\"\\r\\ngrep -o \u0027\\\"type\\\": \\\"[^\\\"]*\\\"\u0027 \\\"$BACKUP_PATH\\\" | sort | uniq -c | sort -nr | while read count type; do\\r\\n    type_name=$(echo \\\"$type\\\" | cut -d\u0027\\\"\u0027 -f4)\\r\\n    echo \\\"  $type_name: $count files\\\"\\r\\ndone\\r\\n\\r\\necho \\\"\\\"\\r\\necho \\\"Backup saved to: $BACKUP_DIR\\\"\\r\\nls -lh \\\"$BACKUP_PATH\\\"\\r\\n"
                  },
                  {
                      "size":  10213,
                      "relativePath":  "scripts\\setup-dev-env.sh",
                      "extension":  ".sh",
                      "lastModified":  "2025-07-10 14:01:36",
                      "directory":  "scripts",
                      "fileName":  "setup-dev-env.sh",
                      "type":  "script",
                      "content":  "#!/bin/bash\\r\\n\\r\\n# HFT Engine Development Environment Setup\\r\\n# Sets up the development environment and installs dependencies\\r\\n# Author: Raja Babu\\r\\n# Date: 2025-07-10\\r\\n\\r\\nset -e\\r\\n\\r\\n# Colors for output\\r\\nRED=\u0027\\\\\\\\033[0;31m\u0027\\r\\nGREEN=\u0027\\\\\\\\033[0;32m\u0027\\r\\nYELLOW=\u0027\\\\\\\\033[1;33m\u0027\\r\\nBLUE=\u0027\\\\\\\\033[0;34m\u0027\\r\\nNC=\u0027\\\\\\\\033[0m\u0027 # No Color\\r\\n\\r\\nSCRIPT_DIR=\\\"$(cd \\\"$(dirname \\\"${BASH_SOURCE[0]}\\\")\\\" \u0026\u0026 pwd)\\\"\\r\\nPROJECT_ROOT=\\\"$(dirname \\\"$SCRIPT_DIR\\\")\\\"\\r\\n\\r\\nlog_info() {\\r\\n    echo -e \\\"${BLUE}[SETUP]${NC} $1\\\"\\r\\n}\\r\\n\\r\\nlog_success() {\\r\\n    echo -e \\\"${GREEN}[SETUP]${NC} $1\\\"\\r\\n}\\r\\n\\r\\nlog_warning() {\\r\\n    echo -e \\\"${YELLOW}[SETUP]${NC} $1\\\"\\r\\n}\\r\\n\\r\\nlog_error() {\\r\\n    echo -e \\\"${RED}[SETUP]${NC} $1\\\"\\r\\n}\\r\\n\\r\\nprint_banner() {\\r\\n    echo \\\"==================================================================\\\"\\r\\n    echo \\\"               HFT ENGINE DEVELOPMENT SETUP                      \\\"\\r\\n    echo \\\"==================================================================\\\"\\r\\n    echo \\\"Setting up development environment...\\\"\\r\\n    echo \\\"==================================================================\\\"\\r\\n}\\r\\n\\r\\ndetect_os() {\\r\\n    if [[ \\\"$OSTYPE\\\" == \\\"linux-gnu\\\"* ]]; then\\r\\n        echo \\\"linux\\\"\\r\\n    elif [[ \\\"$OSTYPE\\\" == \\\"darwin\\\"* ]]; then\\r\\n        echo \\\"macos\\\"\\r\\n    elif [[ \\\"$OSTYPE\\\" == \\\"msys\\\" || \\\"$OSTYPE\\\" == \\\"cygwin\\\" ]]; then\\r\\n        echo \\\"windows\\\"\\r\\n    else\\r\\n        echo \\\"unknown\\\"\\r\\n    fi\\r\\n}\\r\\n\\r\\ninstall_dependencies_ubuntu() {\\r\\n    log_info \\\"Installing dependencies for Ubuntu/Debian...\\\"\\r\\n    \\r\\n    sudo apt update\\r\\n    sudo apt install -y \\\\\\\\\\r\\n        build-essential \\\\\\\\\\r\\n        cmake \\\\\\\\\\r\\n        git \\\\\\\\\\r\\n        libssl-dev \\\\\\\\\\r\\n        libboost-all-dev \\\\\\\\\\r\\n        nlohmann-json3-dev \\\\\\\\\\r\\n        pkg-config \\\\\\\\\\r\\n        lcov \\\\\\\\\\r\\n        gcovr \\\\\\\\\\r\\n        valgrind \\\\\\\\\\r\\n        cppcheck \\\\\\\\\\r\\n        clang-format\\r\\n    \\r\\n    log_success \\\"Ubuntu dependencies installed\\\"\\r\\n}\\r\\n\\r\\ninstall_dependencies_macos() {\\r\\n    log_info \\\"Installing dependencies for macOS...\\\"\\r\\n    \\r\\n    if ! command -v brew \u0026\u003e /dev/null; then\\r\\n        log_error \\\"Homebrew not found. Please install Homebrew first:\\\"\\r\\n        log_info \\\"https://brew.sh/\\\"\\r\\n        exit 1\\r\\n    fi\\r\\n    \\r\\n    brew install \\\\\\\\\\r\\n        cmake \\\\\\\\\\r\\n        boost \\\\\\\\\\r\\n        openssl \\\\\\\\\\r\\n        nlohmann-json \\\\\\\\\\r\\n        lcov \\\\\\\\\\r\\n        cppcheck \\\\\\\\\\r\\n        clang-format\\r\\n    \\r\\n    log_success \\\"macOS dependencies installed\\\"\\r\\n}\\r\\n\\r\\nsetup_git_hooks() {\\r\\n    log_info \\\"Setting up Git hooks...\\\"\\r\\n    \\r\\n    # Create .git/hooks directory if it doesn\u0027t exist\\r\\n    mkdir -p \\\"$PROJECT_ROOT/.git/hooks\\\"\\r\\n    \\r\\n    # Copy pre-commit hook\\r\\n    if [ -f \\\"$SCRIPT_DIR/pre-commit\\\" ]; then\\r\\n        cp \\\"$SCRIPT_DIR/pre-commit\\\" \\\"$PROJECT_ROOT/.git/hooks/pre-commit\\\"\\r\\n        chmod +x \\\"$PROJECT_ROOT/.git/hooks/pre-commit\\\"\\r\\n        log_success \\\"Pre-commit hook installed\\\"\\r\\n    else\\r\\n        log_warning \\\"Pre-commit hook script not found\\\"\\r\\n    fi\\r\\n    \\r\\n    # Make build script executable\\r\\n    if [ -f \\\"$SCRIPT_DIR/hft-build\\\" ]; then\\r\\n        chmod +x \\\"$SCRIPT_DIR/hft-build\\\"\\r\\n        log_success \\\"hft-build script made executable\\\"\\r\\n    fi\\r\\n}\\r\\n\\r\\nsetup_external_dependencies() {\\r\\n    log_info \\\"Setting up external dependencies...\\\"\\r\\n    \\r\\n    # Create external directory\\r\\n    mkdir -p \\\"$PROJECT_ROOT/external\\\"\\r\\n    \\r\\n    # Clone WebSocket++ if not already present\\r\\n    if [ ! -d \\\"$PROJECT_ROOT/external/websocketpp\\\" ]; then\\r\\n        log_info \\\"Cloning WebSocket++ library...\\\"\\r\\n        git clone https://github.com/zaphoyd/websocketpp.git \\\"$PROJECT_ROOT/external/websocketpp\\\"\\r\\n        log_success \\\"WebSocket++ cloned successfully\\\"\\r\\n    else\\r\\n        log_info \\\"WebSocket++ already exists, updating...\\\"\\r\\n        cd \\\"$PROJECT_ROOT/external/websocketpp\\\"\\r\\n        git pull origin develop\\r\\n        cd \\\"$PROJECT_ROOT\\\"\\r\\n    fi\\r\\n}\\r\\n\\r\\nsetup_vscode_config() {\\r\\n    log_info \\\"Setting up VS Code configuration...\\\"\\r\\n    \\r\\n    mkdir -p \\\"$PROJECT_ROOT/.vscode\\\"\\r\\n    \\r\\n    # Create settings.json\\r\\n    cat \u003e \\\"$PROJECT_ROOT/.vscode/settings.json\\\" \u003c\u003c \u0027EOF\u0027\\r\\n{\\r\\n    \\\"C_Cpp.default.configurationProvider\\\": \\\"ms-vscode.cmake-tools\\\",\\r\\n    \\\"C_Cpp.default.cppStandard\\\": \\\"c++17\\\",\\r\\n    \\\"C_Cpp.default.compilerPath\\\": \\\"/usr/bin/g++\\\",\\r\\n    \\\"cmake.buildDirectory\\\": \\\"${workspaceFolder}/build\\\",\\r\\n    \\\"cmake.generator\\\": \\\"Unix Makefiles\\\",\\r\\n    \\\"files.associations\\\": {\\r\\n        \\\"*.h\\\": \\\"cpp\\\",\\r\\n        \\\"*.hpp\\\": \\\"cpp\\\",\\r\\n        \\\"*.cpp\\\": \\\"cpp\\\"\\r\\n    },\\r\\n    \\\"editor.formatOnSave\\\": true,\\r\\n    \\\"C_Cpp.clang_format_style\\\": \\\"Google\\\"\\r\\n}\\r\\nEOF\\r\\n    \\r\\n    # Create launch.json for debugging\\r\\n    cat \u003e \\\"$PROJECT_ROOT/.vscode/launch.json\\\" \u003c\u003c \u0027EOF\u0027\\r\\n{\\r\\n    \\\"version\\\": \\\"0.2.0\\\",\\r\\n    \\\"configurations\\\": [\\r\\n        {\\r\\n            \\\"name\\\": \\\"Debug HFT Engine\\\",\\r\\n            \\\"type\\\": \\\"cppdbg\\\",\\r\\n            \\\"request\\\": \\\"launch\\\",\\r\\n            \\\"program\\\": \\\"${workspaceFolder}/build/hft_engine\\\",\\r\\n            \\\"args\\\": [],\\r\\n            \\\"stopAtEntry\\\": false,\\r\\n            \\\"cwd\\\": \\\"${workspaceFolder}/build\\\",\\r\\n            \\\"environment\\\": [],\\r\\n            \\\"externalConsole\\\": false,\\r\\n            \\\"MIMode\\\": \\\"gdb\\\",\\r\\n            \\\"setupCommands\\\": [\\r\\n                {\\r\\n                    \\\"description\\\": \\\"Enable pretty-printing for gdb\\\",\\r\\n                    \\\"text\\\": \\\"-enable-pretty-printing\\\",\\r\\n                    \\\"ignoreFailures\\\": true\\r\\n                }\\r\\n            ],\\r\\n            \\\"preLaunchTask\\\": \\\"Build HFT Engine\\\"\\r\\n        },\\r\\n        {\\r\\n            \\\"name\\\": \\\"Debug Tests\\\",\\r\\n            \\\"type\\\": \\\"cppdbg\\\",\\r\\n            \\\"request\\\": \\\"launch\\\",\\r\\n            \\\"program\\\": \\\"${workspaceFolder}/build/hft_tests\\\",\\r\\n            \\\"args\\\": [],\\r\\n            \\\"stopAtEntry\\\": false,\\r\\n            \\\"cwd\\\": \\\"${workspaceFolder}/build\\\",\\r\\n            \\\"environment\\\": [],\\r\\n            \\\"externalConsole\\\": false,\\r\\n            \\\"MIMode\\\": \\\"gdb\\\",\\r\\n            \\\"setupCommands\\\": [\\r\\n                {\\r\\n                    \\\"description\\\": \\\"Enable pretty-printing for gdb\\\",\\r\\n                    \\\"text\\\": \\\"-enable-pretty-printing\\\",\\r\\n                    \\\"ignoreFailures\\\": true\\r\\n                }\\r\\n            ],\\r\\n            \\\"preLaunchTask\\\": \\\"Build HFT Engine\\\"\\r\\n        }\\r\\n    ]\\r\\n}\\r\\nEOF\\r\\n    \\r\\n    # Create tasks.json\\r\\n    cat \u003e \\\"$PROJECT_ROOT/.vscode/tasks.json\\\" \u003c\u003c \u0027EOF\u0027\\r\\n{\\r\\n    \\\"version\\\": \\\"2.0.0\\\",\\r\\n    \\\"tasks\\\": [\\r\\n        {\\r\\n            \\\"label\\\": \\\"Build HFT Engine\\\",\\r\\n            \\\"type\\\": \\\"shell\\\",\\r\\n            \\\"command\\\": \\\"${workspaceFolder}/scripts/hft-build\\\",\\r\\n            \\\"group\\\": {\\r\\n                \\\"kind\\\": \\\"build\\\",\\r\\n                \\\"isDefault\\\": true\\r\\n            },\\r\\n            \\\"presentation\\\": {\\r\\n                \\\"echo\\\": true,\\r\\n                \\\"reveal\\\": \\\"always\\\",\\r\\n                \\\"focus\\\": false,\\r\\n                \\\"panel\\\": \\\"shared\\\"\\r\\n            },\\r\\n            \\\"problemMatcher\\\": \\\"$gcc\\\"\\r\\n        },\\r\\n        {\\r\\n            \\\"label\\\": \\\"Build with Coverage\\\",\\r\\n            \\\"type\\\": \\\"shell\\\",\\r\\n            \\\"command\\\": \\\"${workspaceFolder}/scripts/hft-build\\\",\\r\\n            \\\"args\\\": [\\\"--coverage\\\"],\\r\\n            \\\"group\\\": \\\"build\\\",\\r\\n            \\\"presentation\\\": {\\r\\n                \\\"echo\\\": true,\\r\\n                \\\"reveal\\\": \\\"always\\\",\\r\\n                \\\"focus\\\": false,\\r\\n                \\\"panel\\\": \\\"shared\\\"\\r\\n            }\\r\\n        },\\r\\n        {\\r\\n            \\\"label\\\": \\\"Clean Build\\\",\\r\\n            \\\"type\\\": \\\"shell\\\",\\r\\n            \\\"command\\\": \\\"${workspaceFolder}/scripts/hft-build\\\",\\r\\n            \\\"args\\\": [\\\"--clean\\\"],\\r\\n            \\\"group\\\": \\\"build\\\"\\r\\n        },\\r\\n        {\\r\\n            \\\"label\\\": \\\"Run Tests\\\",\\r\\n            \\\"type\\\": \\\"shell\\\",\\r\\n            \\\"command\\\": \\\"${workspaceFolder}/scripts/hft-build\\\",\\r\\n            \\\"args\\\": [\\\"--test-only\\\"],\\r\\n            \\\"group\\\": \\\"test\\\"\\r\\n        }\\r\\n    ]\\r\\n}\\r\\nEOF\\r\\n    \\r\\n    log_success \\\"VS Code configuration created\\\"\\r\\n}\\r\\n\\r\\ncreate_sample_config() {\\r\\n    log_info \\\"Creating sample configuration files...\\\"\\r\\n    \\r\\n    # Create sample auth config (without real credentials)\\r\\n    cat \u003e \\\"$PROJECT_ROOT/auth_config.sample.json\\\" \u003c\u003c \u0027EOF\u0027\\r\\n{\\r\\n    \\\"api_key\\\": \\\"your_binance_api_key_here\\\",\\r\\n    \\\"secret_key\\\": \\\"your_binance_secret_key_here\\\",\\r\\n    \\\"passphrase\\\": \\\"\\\"\\r\\n}\\r\\nEOF\\r\\n    \\r\\n    log_success \\\"Sample configuration files created\\\"\\r\\n    log_warning \\\"Remember to copy auth_config.sample.json to auth_config.json and add real credentials\\\"\\r\\n}\\r\\n\\r\\nverify_installation() {\\r\\n    log_info \\\"Verifying installation...\\\"\\r\\n    \\r\\n    local errors=0\\r\\n    \\r\\n    # Check required tools\\r\\n    local tools=(\\\"cmake\\\" \\\"make\\\" \\\"g++\\\" \\\"git\\\")\\r\\n    for tool in \\\"${tools[@]}\\\"; do\\r\\n        if command -v \\\"$tool\\\" \u0026\u003e /dev/null; then\\r\\n            log_success \\\"$tool found\\\"\\r\\n        else\\r\\n            log_error \\\"$tool not found\\\"\\r\\n            errors=$((errors + 1))\\r\\n        fi\\r\\n    done\\r\\n    \\r\\n    # Check libraries\\r\\n    if pkg-config --exists openssl; then\\r\\n        log_success \\\"OpenSSL found\\\"\\r\\n    else\\r\\n        log_error \\\"OpenSSL not found\\\"\\r\\n        errors=$((errors + 1))\\r\\n    fi\\r\\n    \\r\\n    if [ $errors -eq 0 ]; then\\r\\n        log_success \\\"All dependencies verified\\\"\\r\\n        return 0\\r\\n    else\\r\\n        log_error \\\"$errors dependencies missing\\\"\\r\\n        return 1\\r\\n    fi\\r\\n}\\r\\n\\r\\nmain() {\\r\\n    print_banner\\r\\n    \\r\\n    local os=$(detect_os)\\r\\n    log_info \\\"Detected OS: $os\\\"\\r\\n    \\r\\n    case $os in\\r\\n        \\\"linux\\\")\\r\\n            install_dependencies_ubuntu\\r\\n            ;;\\r\\n        \\\"macos\\\")\\r\\n            install_dependencies_macos\\r\\n            ;;\\r\\n        \\\"windows\\\")\\r\\n            log_warning \\\"Windows detected. Please use WSL or install dependencies manually\\\"\\r\\n            ;;\\r\\n        *)\\r\\n            log_error \\\"Unsupported OS: $os\\\"\\r\\n            exit 1\\r\\n            ;;\\r\\n    esac\\r\\n    \\r\\n    setup_external_dependencies\\r\\n    setup_git_hooks\\r\\n    setup_vscode_config\\r\\n    create_sample_config\\r\\n    \\r\\n    if verify_installation; then\\r\\n        log_success \\\"Development environment setup completed!\\\"\\r\\n        echo \\\"\\\"\\r\\n        echo \\\"==================================================================\\\"\\r\\n        echo \\\"                          NEXT STEPS                             \\\"\\r\\n        echo \\\"==================================================================\\\"\\r\\n        echo \\\"1. Copy auth_config.sample.json to auth_config.json\\\"\\r\\n        echo \\\"2. Add your Binance API credentials to auth_config.json\\\"\\r\\n        echo \\\"3. Run \u0027./scripts/hft-build\u0027 to build the project\\\"\\r\\n        echo \\\"4. Run \u0027./scripts/hft-build --coverage\u0027 to run with coverage\\\"\\r\\n        echo \\\"==================================================================\\\"\\r\\n    else\\r\\n        log_error \\\"Setup completed with errors. Please fix the issues above.\\\"\\r\\n        exit 1\\r\\n    fi\\r\\n}\\r\\n\\r\\nmain \\\"$@\\\"\\r\\n"
                  },
                  {
                      "size":  5359,
                      "relativePath":  "src\\auth_manager.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-10 13:44:42",
                      "directory":  "src",
                      "fileName":  "auth_manager.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/auth_manager.h\\\"\\r\\n#include \u003copenssl/hmac.h\u003e\\r\\n#include \u003copenssl/sha.h\u003e\\r\\n#include \u003cfstream\u003e\\r\\n#include \u003ciostream\u003e\\r\\n#include \u003cchrono\u003e\\r\\n#include \u003ciomanip\u003e\\r\\n#include \u003csstream\u003e\\r\\n#include \u003ccstdlib\u003e\\r\\n#include \u003cnlohmann/json.hpp\u003e\\r\\n\\r\\nusing json = nlohmann::json;\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\nAuthManager::AuthManager() : credentials_loaded_(false), credentials_(nullptr) {}\\r\\n\\r\\nAuthManager::~AuthManager() {\\r\\n    clear_credentials();\\r\\n}\\r\\n\\r\\nbool AuthManager::load_credentials() {\\r\\n    // Try environment variables first\\r\\n    std::string api_key = read_from_env(\\\"BINANCE_API_KEY\\\");\\r\\n    std::string secret_key = read_from_env(\\\"BINANCE_SECRET_KEY\\\");\\r\\n    \\r\\n    if (!api_key.empty() \u0026\u0026 !secret_key.empty()) {\\r\\n        return set_credentials(api_key, secret_key);\\r\\n    }\\r\\n    \\r\\n    // Fallback to config file\\r\\n    return load_credentials_from_file(\\\"auth_config.json\\\");\\r\\n}\\r\\n\\r\\nbool AuthManager::load_credentials_from_file(const std::string\u0026 config_path) {\\r\\n    try {\\r\\n        std::ifstream file(config_path);\\r\\n        if (!file.is_open()) {\\r\\n            std::cerr \u003c\u003c \\\"Warning: Could not open auth config file: \\\" \u003c\u003c config_path \u003c\u003c std::endl;\\r\\n            return false;\\r\\n        }\\r\\n        \\r\\n        json config;\\r\\n        file \u003e\u003e config;\\r\\n        \\r\\n        if (config.contains(\\\"api_key\\\") \u0026\u0026 config.contains(\\\"secret_key\\\")) {\\r\\n            std::string api_key = config[\\\"api_key\\\"];\\r\\n            std::string secret_key = config[\\\"secret_key\\\"];\\r\\n            std::string passphrase = config.value(\\\"passphrase\\\", \\\"\\\");\\r\\n            \\r\\n            credentials_ = std::make_unique\u003cCredentials\u003e();\\r\\n            credentials_-\u003eapi_key = api_key;\\r\\n            credentials_-\u003esecret_key = secret_key;\\r\\n            credentials_-\u003epassphrase = passphrase;\\r\\n            \\r\\n            credentials_loaded_ = validate_credentials();\\r\\n            return credentials_loaded_;\\r\\n        }\\r\\n    } catch (const std::exception\u0026 e) {\\r\\n        std::cerr \u003c\u003c \\\"Error loading credentials: \\\" \u003c\u003c e.what() \u003c\u003c std::endl;\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    return false;\\r\\n}\\r\\n\\r\\nbool AuthManager::set_credentials(const std::string\u0026 api_key, const std::string\u0026 secret_key) {\\r\\n    if (!is_valid_api_key(api_key) || !is_valid_secret(secret_key)) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    credentials_ = std::make_unique\u003cCredentials\u003e();\\r\\n    credentials_-\u003eapi_key = api_key;\\r\\n    credentials_-\u003esecret_key = secret_key;\\r\\n    credentials_-\u003epassphrase = \\\"\\\";\\r\\n    \\r\\n    credentials_loaded_ = true;\\r\\n    return true;\\r\\n}\\r\\n\\r\\nbool AuthManager::validate_credentials() const {\\r\\n    if (!credentials_) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    return is_valid_api_key(credentials_-\u003eapi_key) \u0026\u0026 \\r\\n           is_valid_secret(credentials_-\u003esecret_key);\\r\\n}\\r\\n\\r\\nstd::optional\u003cAuthManager::Credentials\u003e AuthManager::get_credentials() const {\\r\\n    if (!credentials_loaded_ || !credentials_) {\\r\\n        return std::nullopt;\\r\\n    }\\r\\n    \\r\\n    return *credentials_;\\r\\n}\\r\\n\\r\\nstd::string AuthManager::generate_signature(const std::string\u0026 query_string, const std::string\u0026 secret) const {\\r\\n    unsigned char digest[SHA256_DIGEST_LENGTH];\\r\\n    unsigned int digest_len = SHA256_DIGEST_LENGTH;\\r\\n    \\r\\n    HMAC(EVP_sha256(), \\r\\n         secret.c_str(), secret.length(),\\r\\n         reinterpret_cast\u003cconst unsigned char*\u003e(query_string.c_str()), query_string.length(),\\r\\n         digest, \u0026digest_len);\\r\\n    \\r\\n    std::stringstream ss;\\r\\n    for (unsigned int i = 0; i \u003c digest_len; ++i) {\\r\\n        ss \u003c\u003c std::hex \u003c\u003c std::setw(2) \u003c\u003c std::setfill(\u00270\u0027) \u003c\u003c static_cast\u003cint\u003e(digest[i]);\\r\\n    }\\r\\n    \\r\\n    return ss.str();\\r\\n}\\r\\n\\r\\nstd::string AuthManager::get_timestamp() const {\\r\\n    auto now = std::chrono::system_clock::now();\\r\\n    auto timestamp = std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(now.time_since_epoch()).count();\\r\\n    return std::to_string(timestamp);\\r\\n}\\r\\n\\r\\nvoid AuthManager::clear_credentials() {\\r\\n    if (credentials_) {\\r\\n        // Clear sensitive data\\r\\n        credentials_-\u003eapi_key.clear();\\r\\n        credentials_-\u003esecret_key.clear();\\r\\n        credentials_-\u003epassphrase.clear();\\r\\n        credentials_.reset();\\r\\n    }\\r\\n    credentials_loaded_ = false;\\r\\n}\\r\\n\\r\\nbool AuthManager::test_connection() const {\\r\\n    if (!credentials_loaded_) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    // For now, just validate format. In real implementation, \\r\\n    // this would make a test API call to verify credentials\\r\\n    return validate_credentials();\\r\\n}\\r\\n\\r\\nbool AuthManager::is_valid_api_key(const std::string\u0026 key) const {\\r\\n    // Binance API keys are typically 64 characters long and alphanumeric\\r\\n    if (key.length() \u003c 20 || key.length() \u003e 128) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    // Check if it contains only valid characters\\r\\n    for (char c : key) {\\r\\n        if (!std::isalnum(c)) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    return true;\\r\\n}\\r\\n\\r\\nbool AuthManager::is_valid_secret(const std::string\u0026 secret) const {\\r\\n    // Similar validation for secret key\\r\\n    if (secret.length() \u003c 20 || secret.length() \u003e 128) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    for (char c : secret) {\\r\\n        if (!std::isalnum(c) \u0026\u0026 c != \u0027+\u0027 \u0026\u0026 c != \u0027/\u0027 \u0026\u0026 c != \u0027=\u0027) {\\r\\n            return false;\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    return true;\\r\\n}\\r\\n\\r\\nstd::string AuthManager::read_from_env(const std::string\u0026 var_name) const {\\r\\n    const char* value = std::getenv(var_name.c_str());\\r\\n    return value ? std::string(value) : \\\"\\\";\\r\\n}\\r\\n\\r\\n} // namespace hft\\r\\n"
                  },
                  {
                      "size":  750,
                      "relativePath":  "src\\main.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "src",
                      "fileName":  "main.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/matching_engine.h\\\"\\r\\n#include \\\"hft/websocket_client.h\\\"\\r\\n#include \u003cnlohmann/json.hpp\u003e\\r\\n#include \u003cfstream\u003e\\r\\n#include \u003ciostream\u003e\\r\\n\\r\\nint main() {\\r\\n    std::ifstream config_file(\\\"config.json\\\");\\r\\n    if (!config_file.is_open()) {\\r\\n        std::cerr \u003c\u003c \\\"Error: config.json not found!\\\" \u003c\u003c std::endl;\\r\\n        return 1;\\r\\n    }\\r\\n    auto config = nlohmann::json::parse(config_file);\\r\\n\\r\\n    hft::MatchingEngine engine(config[\\\"book_depth\\\"]);\\r\\n    engine.run();\\r\\n\\r\\n    hft::WebsocketClient client(engine, config[\\\"symbol\\\"]);\\r\\n\\r\\n    std::cout \u003c\u003c \\\"Connecting to Binance for symbol: \\\" \u003c\u003c config[\\\"symbol\\\"] \u003c\u003c std::endl;\\r\\n    std::cout \u003c\u003c \\\"Press Ctrl+C to exit.\\\" \u003c\u003c std::endl;\\r\\n\\r\\n    client.run(); // This will block\\r\\n\\r\\n    engine.stop();\\r\\n    return 0;\\r\\n}"
                  },
                  {
                      "size":  1127,
                      "relativePath":  "src\\matching_engine.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-09 21:29:22",
                      "directory":  "src",
                      "fileName":  "matching_engine.cpp",
                      "type":  "source",
                      "content":  "    #include \\\"hft/matching_engine.h\\\"\\r\\n#include \u003cchrono\u003e\\r\\n#include \u003cx86intrin.h\u003e\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\n    MatchingEngine::MatchingEngine(int book_depth) : book_depth_(book_depth) {}\\r\\n\\r\\n    MatchingEngine::~MatchingEngine() {\\r\\n        stop();\\r\\n    }\\r\\n\\r\\n    bool MatchingEngine::post_command(Command\u0026\u0026 cmd) {\\r\\n        Command* heap_cmd = new Command(std::move(cmd));\\r\\n        return command_queue_.push(heap_cmd);\\r\\n    }\\r\\n\\r\\n    void MatchingEngine::run() {\\r\\n        running_ = true;\\r\\n        writer_thread_ = std::thread(\u0026MatchingEngine::writer_thread_func, this);\\r\\n    }\\r\\n\\r\\n    void MatchingEngine::stop() {\\r\\n        running_ = false;\\r\\n        if (writer_thread_.joinable()) {\\r\\n            writer_thread_.join();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    void MatchingEngine::writer_thread_func() {\\r\\n        while (running_) {\\r\\n            Command* cmdPtr = nullptr;\\r\\n            if (command_queue_.pop(cmdPtr)) {\\r\\n                    order_book_.update(*cmdPtr);\\r\\n                    order_book_.print_book(book_depth_);\\r\\n                    delete cmdPtr;\\r\\n            } else {\\r\\n                _mm_pause();\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}"
                  },
                  {
                      "size":  1953,
                      "relativePath":  "src\\order_book.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "src",
                      "fileName":  "order_book.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/order_book.h\\\"\\r\\n#include \u003ciomanip\u003e\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\n    void OrderBook::update(const Command\u0026 cmd) {\\r\\n        bids_.clear();\\r\\n        asks_.clear();\\r\\n        for (const auto\u0026 level : cmd.bids) {\\r\\n            bids_[level.price] = level.quantity;\\r\\n        }\\r\\n        for (const auto\u0026 level : cmd.asks) {\\r\\n            asks_[level.price] = level.quantity;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    void OrderBook::print_book(int depth) const {\\r\\n        auto bid_it = bids_.cbegin();\\r\\n        auto ask_it = asks_.cbegin();\\r\\n\\r\\n        std::cout \u003c\u003c \\\"\\\\\\\\033[2J\\\\\\\\033[1;1H\\\"; // Clear screen\\r\\n        std::cout \u003c\u003c \\\"--- ORDER BOOK ---\\\" \u003c\u003c std::endl;\\r\\n        std::cout \u003c\u003c \\\"------------------------------------\\\" \u003c\u003c std::endl;\\r\\n        std::cout \u003c\u003c \\\"|       BIDS       |       ASKS       |\\\" \u003c\u003c std::endl;\\r\\n        std::cout \u003c\u003c \\\"| Price    | Qty     | Price    | Qty     |\\\" \u003c\u003c std::endl;\\r\\n        std::cout \u003c\u003c \\\"------------------------------------\\\" \u003c\u003c std::endl;\\r\\n\\r\\n        for (int i = 0; i \u003c depth; ++i) {\\r\\n            std::cout \u003c\u003c \\\"| \\\";\\r\\n            if (bid_it != bids_.end()) {\\r\\n                std::cout \u003c\u003c std::fixed \u003c\u003c std::setprecision(2) \u003c\u003c std::setw(8) \u003c\u003c price_to_double(bid_it-\u003efirst) \u003c\u003c \\\" | \\\"\\r\\n                          \u003c\u003c std::setw(7) \u003c\u003c bid_it-\u003esecond \u003c\u003c \\\" |\\\";\\r\\n                ++bid_it;\\r\\n            } else {\\r\\n                std::cout \u003c\u003c std::setw(8) \u003c\u003c \\\" \\\" \u003c\u003c \\\" | \\\" \u003c\u003c std::setw(7) \u003c\u003c \\\" \\\" \u003c\u003c \\\" |\\\";\\r\\n            }\\r\\n\\r\\n            if (ask_it != asks_.end()) {\\r\\n                std::cout \u003c\u003c \\\" \\\" \u003c\u003c std::fixed \u003c\u003c std::setprecision(2) \u003c\u003c std::setw(8) \u003c\u003c price_to_double(ask_it-\u003efirst) \u003c\u003c \\\" | \\\"\\r\\n                          \u003c\u003c std::setw(7) \u003c\u003c ask_it-\u003esecond \u003c\u003c \\\" |\\\";\\r\\n                ++ask_it;\\r\\n            } else {\\r\\n                std::cout \u003c\u003c \\\" \\\" \u003c\u003c std::setw(8) \u003c\u003c \\\" \\\" \u003c\u003c \\\" | \\\" \u003c\u003c std::setw(7) \u003c\u003c \\\" \\\" \u003c\u003c \\\" |\\\";\\r\\n            }\\r\\n            std::cout \u003c\u003c std::endl;\\r\\n        }\\r\\n        std::cout \u003c\u003c \\\"------------------------------------\\\" \u003c\u003c std::endl;\\r\\n    }\\r\\n}"
                  },
                  {
                      "size":  10812,
                      "relativePath":  "src\\trading_client.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-10 13:45:35",
                      "directory":  "src",
                      "fileName":  "trading_client.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/trading_client.h\\\"\\r\\n#include \u003ciostream\u003e\\r\\n#include \u003cchrono\u003e\\r\\n#include \u003crandom\u003e\\r\\n#include \u003cthread\u003e\\r\\n#include \u003cnlohmann/json.hpp\u003e\\r\\n\\r\\nusing json = nlohmann::json;\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\nTradingClient::TradingClient(std::shared_ptr\u003cAuthManager\u003e auth_manager)\\r\\n    : auth_manager_(auth_manager), connected_(false), max_order_value_(10000.0) {}\\r\\n\\r\\nTradingClient::~TradingClient() {\\r\\n    disconnect();\\r\\n}\\r\\n\\r\\nbool TradingClient::connect() {\\r\\n    if (!auth_manager_ || !auth_manager_-\u003evalidate_credentials()) {\\r\\n        handle_error(\\\"Invalid or missing credentials\\\");\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    // In a real implementation, this would establish connection to Binance API\\r\\n    // For now, we\u0027ll simulate a connection\\r\\n    try {\\r\\n        // Simulate connection delay\\r\\n        std::this_thread::sleep_for(std::chrono::milliseconds(500));\\r\\n        \\r\\n        // Test credentials\\r\\n        if (!auth_manager_-\u003etest_connection()) {\\r\\n            handle_error(\\\"Authentication failed\\\");\\r\\n            return false;\\r\\n        }\\r\\n        \\r\\n        connected_ = true;\\r\\n        return true;\\r\\n    } catch (const std::exception\u0026 e) {\\r\\n        handle_error(\\\"Connection failed: \\\" + std::string(e.what()));\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid TradingClient::disconnect() {\\r\\n    connected_ = false;\\r\\n    active_orders_.clear();\\r\\n}\\r\\n\\r\\nbool TradingClient::is_connected() const {\\r\\n    return connected_;\\r\\n}\\r\\n\\r\\nstd::future\u003cOrderId\u003e TradingClient::place_order(const Symbol\u0026 symbol, Side side, OrderType type,\\r\\n                                               Price price, Quantity quantity, TimeInForce tif) {\\r\\n    return std::async(std::launch::async, [this, symbol, side, type, price, quantity, tif]() -\u003e OrderId {\\r\\n        if (!connected_) {\\r\\n            handle_error(\\\"Not connected to exchange\\\");\\r\\n            return \\\"\\\";\\r\\n        }\\r\\n        \\r\\n        if (!validate_order(symbol, side, price, quantity)) {\\r\\n            handle_error(\\\"Order validation failed\\\");\\r\\n            return \\\"\\\";\\r\\n        }\\r\\n        \\r\\n        try {\\r\\n            // Generate unique order ID\\r\\n            OrderId order_id = generate_order_id();\\r\\n            \\r\\n            // Create order object\\r\\n            Order order;\\r\\n            order.id = order_id;\\r\\n            order.symbol = symbol;\\r\\n            order.side = side;\\r\\n            order.type = type;\\r\\n            order.price = price;\\r\\n            order.quantity = quantity;\\r\\n            order.time_in_force = tif;\\r\\n            order.timestamp = std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(\\r\\n                std::chrono::system_clock::now().time_since_epoch()).count();\\r\\n            \\r\\n            // In real implementation, this would send HTTP request to Binance\\r\\n            // For now, simulate API call delay\\r\\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\\r\\n            \\r\\n            // Store order in active orders\\r\\n            active_orders_[order_id] = order;\\r\\n            \\r\\n            // Notify callback if set\\r\\n            if (order_callback_) {\\r\\n                order_callback_(order);\\r\\n            }\\r\\n            \\r\\n            return order_id;\\r\\n        } catch (const std::exception\u0026 e) {\\r\\n            handle_error(\\\"Failed to place order: \\\" + std::string(e.what()));\\r\\n            return \\\"\\\";\\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cbool\u003e TradingClient::cancel_order(const OrderId\u0026 order_id) {\\r\\n    return std::async(std::launch::async, [this, order_id]() -\u003e bool {\\r\\n        if (!connected_) {\\r\\n            handle_error(\\\"Not connected to exchange\\\");\\r\\n            return false;\\r\\n        }\\r\\n        \\r\\n        auto it = active_orders_.find(order_id);\\r\\n        if (it == active_orders_.end()) {\\r\\n            handle_error(\\\"Order not found: \\\" + order_id);\\r\\n            return false;\\r\\n        }\\r\\n        \\r\\n        try {\\r\\n            // Simulate API call delay\\r\\n            std::this_thread::sleep_for(std::chrono::milliseconds(50));\\r\\n            \\r\\n            // Update order status\\r\\n            it-\u003esecond.status = OrderStatus::CANCELED;\\r\\n            \\r\\n            // Notify callback\\r\\n            if (order_callback_) {\\r\\n                order_callback_(it-\u003esecond);\\r\\n            }\\r\\n            \\r\\n            // Remove from active orders\\r\\n            active_orders_.erase(it);\\r\\n            \\r\\n            return true;\\r\\n        } catch (const std::exception\u0026 e) {\\r\\n            handle_error(\\\"Failed to cancel order: \\\" + std::string(e.what()));\\r\\n            return false;\\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cbool\u003e TradingClient::cancel_all_orders(const Symbol\u0026 symbol) {\\r\\n    return std::async(std::launch::async, [this, symbol]() -\u003e bool {\\r\\n        if (!connected_) {\\r\\n            handle_error(\\\"Not connected to exchange\\\");\\r\\n            return false;\\r\\n        }\\r\\n        \\r\\n        try {\\r\\n            std::vector\u003cOrderId\u003e orders_to_cancel;\\r\\n            \\r\\n            for (const auto\u0026 [order_id, order] : active_orders_) {\\r\\n                if (symbol.empty() || order.symbol == symbol) {\\r\\n                    orders_to_cancel.push_back(order_id);\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            // Cancel each order\\r\\n            for (const auto\u0026 order_id : orders_to_cancel) {\\r\\n                auto future = cancel_order(order_id);\\r\\n                future.wait(); // Wait for each cancellation\\r\\n            }\\r\\n            \\r\\n            return true;\\r\\n        } catch (const std::exception\u0026 e) {\\r\\n            handle_error(\\\"Failed to cancel all orders: \\\" + std::string(e.what()));\\r\\n            return false;\\r\\n        }\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cstd::vector\u003cOrder\u003e\u003e TradingClient::get_open_orders(const Symbol\u0026 symbol) {\\r\\n    return std::async(std::launch::async, [this, symbol]() -\u003e std::vector\u003cOrder\u003e {\\r\\n        std::vector\u003cOrder\u003e orders;\\r\\n        \\r\\n        for (const auto\u0026 [order_id, order] : active_orders_) {\\r\\n            if (symbol.empty() || order.symbol == symbol) {\\r\\n                orders.push_back(order);\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return orders;\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cstd::vector\u003cTrade\u003e\u003e TradingClient::get_trade_history(const Symbol\u0026 symbol, int limit) {\\r\\n    return std::async(std::launch::async, [this, symbol, limit]() -\u003e std::vector\u003cTrade\u003e {\\r\\n        // Mock trade history\\r\\n        std::vector\u003cTrade\u003e trades;\\r\\n        \\r\\n        // In real implementation, this would fetch from API\\r\\n        // For now, return empty vector\\r\\n        return trades;\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cdouble\u003e TradingClient::get_account_balance(const std::string\u0026 asset) {\\r\\n    return std::async(std::launch::async, [this, asset]() -\u003e double {\\r\\n        // Mock balance\\r\\n        if (asset == \\\"USDT\\\") {\\r\\n            return 10000.0; // Mock USDT balance\\r\\n        } else if (asset == \\\"BTC\\\") {\\r\\n            return 0.5; // Mock BTC balance\\r\\n        }\\r\\n        return 0.0;\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cOrder\u003e TradingClient::get_order_status(const OrderId\u0026 order_id) {\\r\\n    return std::async(std::launch::async, [this, order_id]() -\u003e Order {\\r\\n        auto it = active_orders_.find(order_id);\\r\\n        if (it != active_orders_.end()) {\\r\\n            return it-\u003esecond;\\r\\n        }\\r\\n        \\r\\n        // Return empty order if not found\\r\\n        Order empty_order;\\r\\n        empty_order.status = OrderStatus::REJECTED;\\r\\n        return empty_order;\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cdouble\u003e TradingClient::get_current_price(const Symbol\u0026 symbol) {\\r\\n    return std::async(std::launch::async, [this, symbol]() -\u003e double {\\r\\n        // Mock current price - in real implementation, fetch from API\\r\\n        if (symbol == \\\"BTCUSDT\\\" || symbol == \\\"btcusdt\\\") {\\r\\n            return 45000.0 + (rand() % 1000 - 500); // Random price around 45000\\r\\n        }\\r\\n        return 0.0;\\r\\n    });\\r\\n}\\r\\n\\r\\nstd::future\u003cstd::pair\u003cPrice, Price\u003e\u003e TradingClient::get_bid_ask_spread(const Symbol\u0026 symbol) {\\r\\n    return std::async(std::launch::async, [this, symbol]() -\u003e std::pair\u003cPrice, Price\u003e {\\r\\n        // Mock bid/ask spread\\r\\n        double mid_price = 45000.0;\\r\\n        double spread = 0.5;\\r\\n        return {mid_price - spread, mid_price + spread};\\r\\n    });\\r\\n}\\r\\n\\r\\nvoid TradingClient::set_order_callback(OrderCallback callback) {\\r\\n    order_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid TradingClient::set_trade_callback(TradeCallback callback) {\\r\\n    trade_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid TradingClient::set_error_callback(ErrorCallback callback) {\\r\\n    error_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid TradingClient::set_max_position_size(const Symbol\u0026 symbol, Quantity max_size) {\\r\\n    max_position_sizes_[symbol] = max_size;\\r\\n}\\r\\n\\r\\nvoid TradingClient::set_max_order_value(double max_value) {\\r\\n    max_order_value_ = max_value;\\r\\n}\\r\\n\\r\\nbool TradingClient::validate_order(const Symbol\u0026 symbol, Side side, Price price, Quantity quantity) const {\\r\\n    if (!validate_price(price) || !validate_quantity(quantity)) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    return check_risk_limits(symbol, side, price, quantity);\\r\\n}\\r\\n\\r\\nOrderId TradingClient::generate_order_id() {\\r\\n    static std::random_device rd;\\r\\n    static std::mt19937 gen(rd());\\r\\n    static std::uniform_int_distribution\u003c\u003e dis(100000, 999999);\\r\\n    \\r\\n    return \\\"ORDER_\\\" + std::to_string(dis(gen));\\r\\n}\\r\\n\\r\\nstd::string TradingClient::get_current_timestamp() {\\r\\n    auto now = std::chrono::system_clock::now();\\r\\n    auto timestamp = std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(now.time_since_epoch()).count();\\r\\n    return std::to_string(timestamp);\\r\\n}\\r\\n\\r\\nbool TradingClient::check_connection() {\\r\\n    return connected_;\\r\\n}\\r\\n\\r\\nvoid TradingClient::handle_error(const std::string\u0026 error_message) {\\r\\n    std::cerr \u003c\u003c \\\"TradingClient Error: \\\" \u003c\u003c error_message \u003c\u003c std::endl;\\r\\n    \\r\\n    if (error_callback_) {\\r\\n        error_callback_(error_message);\\r\\n    }\\r\\n}\\r\\n\\r\\nbool TradingClient::validate_price(Price price) const {\\r\\n    return price \u003e 0.0 \u0026\u0026 price \u003c 1000000.0; // Reasonable price bounds\\r\\n}\\r\\n\\r\\nbool TradingClient::validate_quantity(Quantity quantity) const {\\r\\n    return quantity \u003e 0.0 \u0026\u0026 quantity \u003c 1000.0; // Reasonable quantity bounds\\r\\n}\\r\\n\\r\\nbool TradingClient::check_risk_limits(const Symbol\u0026 symbol, Side side, Price price, Quantity quantity) const {\\r\\n    double order_value = price * quantity;\\r\\n    \\r\\n    // Check max order value\\r\\n    if (order_value \u003e max_order_value_) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    // Check position size limits\\r\\n    auto it = max_position_sizes_.find(symbol);\\r\\n    if (it != max_position_sizes_.end() \u0026\u0026 quantity \u003e it-\u003esecond) {\\r\\n        return false;\\r\\n    }\\r\\n    \\r\\n    return true;\\r\\n}\\r\\n\\r\\nstd::string TradingClient::make_authenticated_request(const std::string\u0026 endpoint, \\r\\n                                                     const std::string\u0026 method, \\r\\n                                                     const std::string\u0026 params) {\\r\\n    // In real implementation, this would make HTTP requests to Binance API\\r\\n    // For now, return mock response\\r\\n    return \\\"{\\\\\\\\\\\"status\\\\\\\\\\\":\\\\\\\\\\\"success\\\\\\\\\\\"}\\\";\\r\\n}\\r\\n\\r\\n} // namespace hft\\r\\n"
                  },
                  {
                      "size":  13976,
                      "relativePath":  "src\\ui_manager.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-10 13:46:49",
                      "directory":  "src",
                      "fileName":  "ui_manager.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/ui_manager.h\\\"\\r\\n#include \u003ciostream\u003e\\r\\n#include \u003ciomanip\u003e\\r\\n#include \u003csstream\u003e\\r\\n#include \u003climits\u003e\\r\\n#include \u003cthread\u003e\\r\\n#include \u003cchrono\u003e\\r\\n\\r\\n#ifdef _WIN32\\r\\n#include \u003cwindows.h\u003e\\r\\n#include \u003cconio.h\u003e\\r\\n#else\\r\\n#include \u003ctermios.h\u003e\\r\\n#include \u003cunistd.h\u003e\\r\\n#endif\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\n// Color constants\\r\\nconst std::string UIManager::RESET = \\\"\\\\\\\\033[0m\\\";\\r\\nconst std::string UIManager::RED = \\\"\\\\\\\\033[31m\\\";\\r\\nconst std::string UIManager::GREEN = \\\"\\\\\\\\033[32m\\\";\\r\\nconst std::string UIManager::YELLOW = \\\"\\\\\\\\033[33m\\\";\\r\\nconst std::string UIManager::BLUE = \\\"\\\\\\\\033[34m\\\";\\r\\nconst std::string UIManager::CYAN = \\\"\\\\\\\\033[36m\\\";\\r\\nconst std::string UIManager::WHITE = \\\"\\\\\\\\033[37m\\\";\\r\\n\\r\\nUIManager::UIManager() \\r\\n    : current_mode_(UIMode::LOGIN), running_(false), initialized_(false), connection_status_(false) {}\\r\\n\\r\\nUIManager::~UIManager() {\\r\\n    cleanup();\\r\\n}\\r\\n\\r\\nbool UIManager::initialize() {\\r\\n    if (initialized_) {\\r\\n        return true;\\r\\n    }\\r\\n    \\r\\n    try {\\r\\n        // Initialize terminal settings\\r\\n        clear_screen();\\r\\n        initialized_ = true;\\r\\n        return true;\\r\\n    } catch (const std::exception\u0026 e) {\\r\\n        std::cerr \u003c\u003c \\\"Failed to initialize UI: \\\" \u003c\u003c e.what() \u003c\u003c std::endl;\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::cleanup() {\\r\\n    if (initialized_) {\\r\\n        clear_screen();\\r\\n        initialized_ = false;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::run() {\\r\\n    if (!initialize()) {\\r\\n        return;\\r\\n    }\\r\\n    \\r\\n    running_ = true;\\r\\n    \\r\\n    while (running_) {\\r\\n        try {\\r\\n            switch (current_mode_) {\\r\\n                case UIMode::LOGIN:\\r\\n                    display_login_screen();\\r\\n                    break;\\r\\n                case UIMode::MAIN_MENU:\\r\\n                    display_main_menu();\\r\\n                    break;\\r\\n                case UIMode::ORDER_BOOK_VIEW:\\r\\n                    // This would display live order book - for now just show menu\\r\\n                    display_main_menu();\\r\\n                    break;\\r\\n                case UIMode::ORDER_MANAGEMENT:\\r\\n                    // This would show order management interface\\r\\n                    display_main_menu();\\r\\n                    break;\\r\\n                case UIMode::ACCOUNT_INFO:\\r\\n                    // This would show account information\\r\\n                    display_main_menu();\\r\\n                    break;\\r\\n                case UIMode::SETTINGS:\\r\\n                    // This would show settings\\r\\n                    display_main_menu();\\r\\n                    break;\\r\\n            }\\r\\n            \\r\\n            // Small delay to prevent excessive CPU usage\\r\\n            std::this_thread::sleep_for(std::chrono::milliseconds(100));\\r\\n        } catch (const std::exception\u0026 e) {\\r\\n            display_error(\\\"UI Error: \\\" + std::string(e.what()));\\r\\n            std::this_thread::sleep_for(std::chrono::seconds(2));\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::stop() {\\r\\n    running_ = false;\\r\\n}\\r\\n\\r\\nvoid UIManager::set_mode(UIMode mode) {\\r\\n    current_mode_ = mode;\\r\\n    clear_screen();\\r\\n}\\r\\n\\r\\nUIMode UIManager::get_current_mode() const {\\r\\n    return current_mode_;\\r\\n}\\r\\n\\r\\nvoid UIManager::display_login_screen() {\\r\\n    clear_screen();\\r\\n    print_header(\\\"HFT ENGINE - LOGIN\\\");\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n    print_colored(\\\"Welcome to the High-Frequency Trading Engine\\\", CYAN);\\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\n\\\\\\\\n\\\";\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"Please enter your API credentials:\\\\\\\\n\\\\\\\\n\\\";\\r\\n    \\r\\n    auto credentials = get_login_credentials();\\r\\n    \\r\\n    // Call login callback if set\\r\\n    if (login_callback_) {\\r\\n        bool success = login_callback_(credentials.first, credentials.second);\\r\\n        if (success) {\\r\\n            display_status(\\\"Login successful!\\\");\\r\\n            std::this_thread::sleep_for(std::chrono::seconds(1));\\r\\n            set_mode(UIMode::MAIN_MENU);\\r\\n        } else {\\r\\n            display_error(\\\"Login failed! Please check your credentials.\\\");\\r\\n            std::this_thread::sleep_for(std::chrono::seconds(2));\\r\\n        }\\r\\n    } else {\\r\\n        // No callback set, assume success for demo\\r\\n        display_status(\\\"Demo mode - Login bypassed\\\");\\r\\n        std::this_thread::sleep_for(std::chrono::seconds(1));\\r\\n        set_mode(UIMode::MAIN_MENU);\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::display_main_menu() {\\r\\n    clear_screen();\\r\\n    print_header(\\\"HFT ENGINE - MAIN MENU\\\");\\r\\n    \\r\\n    // Show connection status\\r\\n    if (connection_status_) {\\r\\n        print_colored(\\\"Status: CONNECTED\\\", GREEN);\\r\\n    } else {\\r\\n        print_colored(\\\"Status: DISCONNECTED\\\", RED);\\r\\n    }\\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\n\\\\\\\\n\\\";\\r\\n    \\r\\n    std::vector\u003cstd::string\u003e options = {\\r\\n        \\\"1. View Order Book\\\",\\r\\n        \\\"2. Order Management\\\",\\r\\n        \\\"3. Account Information\\\",\\r\\n        \\\"4. Settings\\\",\\r\\n        \\\"5. Exit\\\"\\r\\n    };\\r\\n    \\r\\n    draw_menu(options);\\r\\n    \\r\\n    int choice = get_menu_choice(options);\\r\\n    \\r\\n    switch (choice) {\\r\\n        case 1:\\r\\n            set_mode(UIMode::ORDER_BOOK_VIEW);\\r\\n            break;\\r\\n        case 2:\\r\\n            set_mode(UIMode::ORDER_MANAGEMENT);\\r\\n            break;\\r\\n        case 3:\\r\\n            set_mode(UIMode::ACCOUNT_INFO);\\r\\n            break;\\r\\n        case 4:\\r\\n            set_mode(UIMode::SETTINGS);\\r\\n            break;\\r\\n        case 5:\\r\\n            stop();\\r\\n            break;\\r\\n        default:\\r\\n            display_error(\\\"Invalid choice\\\");\\r\\n            std::this_thread::sleep_for(std::chrono::seconds(1));\\r\\n            break;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::display_order_book(const OrderBook\u0026 order_book, int depth) {\\r\\n    clear_screen();\\r\\n    print_header(\\\"REAL-TIME ORDER BOOK\\\");\\r\\n    \\r\\n    // This would integrate with the existing order book display\\r\\n    // For now, show placeholder\\r\\n    std::cout \u003c\u003c \\\"Order book display would appear here...\\\\\\\\n\\\";\\r\\n    std::cout \u003c\u003c \\\"Press any key to return to main menu...\\\\\\\\n\\\";\\r\\n    wait_for_key();\\r\\n    set_mode(UIMode::MAIN_MENU);\\r\\n}\\r\\n\\r\\nvoid UIManager::display_order_management(const std::vector\u003cOrder\u003e\u0026 orders) {\\r\\n    clear_screen();\\r\\n    print_header(\\\"ORDER MANAGEMENT\\\");\\r\\n    \\r\\n    if (orders.empty()) {\\r\\n        std::cout \u003c\u003c \\\"No active orders.\\\\\\\\n\\\\\\\\n\\\";\\r\\n    } else {\\r\\n        draw_order_table(orders);\\r\\n    }\\r\\n    \\r\\n    std::vector\u003cstd::string\u003e options = {\\r\\n        \\\"1. Place New Order\\\",\\r\\n        \\\"2. Cancel Order\\\",\\r\\n        \\\"3. Cancel All Orders\\\",\\r\\n        \\\"4. Refresh\\\",\\r\\n        \\\"5. Back to Main Menu\\\"\\r\\n    };\\r\\n    \\r\\n    draw_menu(options);\\r\\n    \\r\\n    int choice = get_menu_choice(options);\\r\\n    \\r\\n    switch (choice) {\\r\\n        case 1: {\\r\\n            Order new_order = get_order_input(\\\"BTCUSDT\\\");\\r\\n            if (order_callback_) {\\r\\n                order_callback_(new_order.symbol, new_order.side, new_order.type, \\r\\n                               new_order.price, new_order.quantity);\\r\\n            }\\r\\n            break;\\r\\n        }\\r\\n        case 2: {\\r\\n            std::string order_id = get_cancel_order_id();\\r\\n            if (!order_id.empty() \u0026\u0026 cancel_callback_) {\\r\\n                cancel_callback_(order_id);\\r\\n            }\\r\\n            break;\\r\\n        }\\r\\n        case 3:\\r\\n            // Cancel all orders logic\\r\\n            display_status(\\\"Cancelling all orders...\\\");\\r\\n            break;\\r\\n        case 4:\\r\\n            // Refresh logic\\r\\n            break;\\r\\n        case 5:\\r\\n            set_mode(UIMode::MAIN_MENU);\\r\\n            break;\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::display_account_info(double balance, const std::vector\u003cTrade\u003e\u0026 recent_trades) {\\r\\n    clear_screen();\\r\\n    print_header(\\\"ACCOUNT INFORMATION\\\");\\r\\n    \\r\\n    std::cout \u003c\u003c std::fixed \u003c\u003c std::setprecision(2);\\r\\n    std::cout \u003c\u003c \\\"Account Balance: $\\\" \u003c\u003c balance \u003c\u003c \\\" USDT\\\\\\\\n\\\\\\\\n\\\";\\r\\n    \\r\\n    if (!recent_trades.empty()) {\\r\\n        std::cout \u003c\u003c \\\"Recent Trades:\\\\\\\\n\\\";\\r\\n        std::cout \u003c\u003c std::left \u003c\u003c std::setw(15) \u003c\u003c \\\"Order ID\\\" \\r\\n                  \u003c\u003c std::setw(10) \u003c\u003c \\\"Side\\\" \\r\\n                  \u003c\u003c std::setw(12) \u003c\u003c \\\"Price\\\" \\r\\n                  \u003c\u003c std::setw(12) \u003c\u003c \\\"Quantity\\\" \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n        print_separator();\\r\\n        \\r\\n        for (const auto\u0026 trade : recent_trades) {\\r\\n            std::cout \u003c\u003c std::left \u003c\u003c std::setw(15) \u003c\u003c trade.order_id\\r\\n                      \u003c\u003c std::setw(10) \u003c\u003c (trade.side == Side::BUY ? \\\"BUY\\\" : \\\"SELL\\\")\\r\\n                      \u003c\u003c std::setw(12) \u003c\u003c trade.price\\r\\n                      \u003c\u003c std::setw(12) \u003c\u003c trade.quantity \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\nPress any key to return to main menu...\\\";\\r\\n    wait_for_key();\\r\\n    set_mode(UIMode::MAIN_MENU);\\r\\n}\\r\\n\\r\\nvoid UIManager::display_error(const std::string\u0026 message) {\\r\\n    print_colored(\\\"ERROR: \\\" + message, RED);\\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n}\\r\\n\\r\\nvoid UIManager::display_status(const std::string\u0026 message) {\\r\\n    print_colored(\\\"STATUS: \\\" + message, GREEN);\\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n}\\r\\n\\r\\nstd::pair\u003cstd::string, std::string\u003e UIManager::get_login_credentials() {\\r\\n    std::string api_key, secret_key;\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"API Key: \\\";\\r\\n    std::getline(std::cin, api_key);\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"Secret Key: \\\";\\r\\n    std::getline(std::cin, secret_key);\\r\\n    \\r\\n    return {api_key, secret_key};\\r\\n}\\r\\n\\r\\nint UIManager::get_menu_choice(const std::vector\u003cstd::string\u003e\u0026 options) {\\r\\n    std::cout \u003c\u003c \\\"\\\\\\\\nEnter your choice: \\\";\\r\\n    int choice;\\r\\n    std::cin \u003e\u003e choice;\\r\\n    \\r\\n    // Clear input buffer\\r\\n    std::cin.clear();\\r\\n    std::cin.ignore(std::numeric_limits\u003cstd::streamsize\u003e::max(), \u0027\\\\\\\\n\u0027);\\r\\n    \\r\\n    return choice;\\r\\n}\\r\\n\\r\\nOrder UIManager::get_order_input(const Symbol\u0026 symbol) {\\r\\n    clear_screen();\\r\\n    print_header(\\\"PLACE NEW ORDER\\\");\\r\\n    \\r\\n    Order order;\\r\\n    order.symbol = symbol;\\r\\n    \\r\\n    std::cout \u003c\u003c \\\"Symbol: \\\" \u003c\u003c symbol \u003c\u003c \\\"\\\\\\\\n\\\\\\\\n\\\";\\r\\n    \\r\\n    // Get side\\r\\n    std::cout \u003c\u003c \\\"Side (1=BUY, 2=SELL): \\\";\\r\\n    int side_choice;\\r\\n    std::cin \u003e\u003e side_choice;\\r\\n    order.side = (side_choice == 1) ? Side::BUY : Side::SELL;\\r\\n    \\r\\n    // Get order type\\r\\n    std::cout \u003c\u003c \\\"Order Type (1=MARKET, 2=LIMIT): \\\";\\r\\n    int type_choice;\\r\\n    std::cin \u003e\u003e type_choice;\\r\\n    order.type = (type_choice == 1) ? OrderType::MARKET : OrderType::LIMIT;\\r\\n    \\r\\n    // Get price (if limit order)\\r\\n    if (order.type == OrderType::LIMIT) {\\r\\n        order.price = get_numeric_input(\\\"Price: \\\");\\r\\n    }\\r\\n    \\r\\n    // Get quantity\\r\\n    order.quantity = get_numeric_input(\\\"Quantity: \\\");\\r\\n    \\r\\n    // Clear input buffer\\r\\n    std::cin.clear();\\r\\n    std::cin.ignore(std::numeric_limits\u003cstd::streamsize\u003e::max(), \u0027\\\\\\\\n\u0027);\\r\\n    \\r\\n    return order;\\r\\n}\\r\\n\\r\\nstd::string UIManager::get_cancel_order_id() {\\r\\n    std::string order_id = get_input(\\\"Enter Order ID to cancel: \\\");\\r\\n    return order_id;\\r\\n}\\r\\n\\r\\nvoid UIManager::set_login_callback(LoginCallback callback) {\\r\\n    login_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid UIManager::set_order_callback(OrderCallback callback) {\\r\\n    order_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid UIManager::set_cancel_callback(CancelCallback callback) {\\r\\n    cancel_callback_ = callback;\\r\\n}\\r\\n\\r\\nvoid UIManager::update_connection_status(bool connected) {\\r\\n    connection_status_ = connected;\\r\\n}\\r\\n\\r\\nvoid UIManager::update_order_book(const OrderBook\u0026 order_book) {\\r\\n    // Implementation would update order book display\\r\\n}\\r\\n\\r\\nvoid UIManager::update_orders(const std::vector\u003cOrder\u003e\u0026 orders) {\\r\\n    // Implementation would update order display\\r\\n}\\r\\n\\r\\nvoid UIManager::update_balance(double balance) {\\r\\n    // Implementation would update balance display\\r\\n}\\r\\n\\r\\nvoid UIManager::clear_screen() {\\r\\n#ifdef _WIN32\\r\\n    system(\\\"cls\\\");\\r\\n#else\\r\\n    system(\\\"clear\\\");\\r\\n#endif\\r\\n}\\r\\n\\r\\nvoid UIManager::print_header(const std::string\u0026 title) {\\r\\n    print_separator();\\r\\n    std::cout \u003c\u003c \\\"â”‚ \\\" \u003c\u003c std::left \u003c\u003c std::setw(76) \u003c\u003c title \u003c\u003c \\\" â”‚\\\\\\\\n\\\";\\r\\n    print_separator();\\r\\n}\\r\\n\\r\\nvoid UIManager::print_separator() {\\r\\n    std::cout \u003c\u003c \\\"â”Œ\\\" \u003c\u003c std::string(78, \u0027â”€\u0027) \u003c\u003c \\\"â”\\\\\\\\n\\\";\\r\\n}\\r\\n\\r\\nvoid UIManager::wait_for_key() {\\r\\n#ifdef _WIN32\\r\\n    _getch();\\r\\n#else\\r\\n    getchar();\\r\\n#endif\\r\\n}\\r\\n\\r\\nstd::string UIManager::get_input(const std::string\u0026 prompt) {\\r\\n    std::cout \u003c\u003c prompt;\\r\\n    std::string input;\\r\\n    std::getline(std::cin, input);\\r\\n    return input;\\r\\n}\\r\\n\\r\\ndouble UIManager::get_numeric_input(const std::string\u0026 prompt) {\\r\\n    std::cout \u003c\u003c prompt;\\r\\n    double value;\\r\\n    std::cin \u003e\u003e value;\\r\\n    return value;\\r\\n}\\r\\n\\r\\nchar UIManager::get_char_input() {\\r\\n#ifdef _WIN32\\r\\n    return _getch();\\r\\n#else\\r\\n    return getchar();\\r\\n#endif\\r\\n}\\r\\n\\r\\nvoid UIManager::print_colored(const std::string\u0026 text, const std::string\u0026 color) {\\r\\n    std::cout \u003c\u003c color \u003c\u003c text \u003c\u003c RESET;\\r\\n}\\r\\n\\r\\nvoid UIManager::draw_border() {\\r\\n    std::cout \u003c\u003c \\\"+\\\" \u003c\u003c std::string(78, \u0027-\u0027) \u003c\u003c \\\"+\\\\\\\\n\\\";\\r\\n}\\r\\n\\r\\nvoid UIManager::draw_order_book_table(const OrderBook\u0026 order_book, int depth) {\\r\\n    // Implementation would draw order book table\\r\\n}\\r\\n\\r\\nvoid UIManager::draw_order_table(const std::vector\u003cOrder\u003e\u0026 orders) {\\r\\n    std::cout \u003c\u003c std::left \u003c\u003c std::setw(15) \u003c\u003c \\\"Order ID\\\" \\r\\n              \u003c\u003c std::setw(10) \u003c\u003c \\\"Symbol\\\" \\r\\n              \u003c\u003c std::setw(8) \u003c\u003c \\\"Side\\\" \\r\\n              \u003c\u003c std::setw(10) \u003c\u003c \\\"Type\\\"\\r\\n              \u003c\u003c std::setw(12) \u003c\u003c \\\"Price\\\" \\r\\n              \u003c\u003c std::setw(12) \u003c\u003c \\\"Quantity\\\" \\r\\n              \u003c\u003c std::setw(10) \u003c\u003c \\\"Status\\\" \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n    print_separator();\\r\\n    \\r\\n    for (const auto\u0026 order : orders) {\\r\\n        std::cout \u003c\u003c std::left \u003c\u003c std::setw(15) \u003c\u003c order.id\\r\\n                  \u003c\u003c std::setw(10) \u003c\u003c order.symbol\\r\\n                  \u003c\u003c std::setw(8) \u003c\u003c (order.side == Side::BUY ? \\\"BUY\\\" : \\\"SELL\\\")\\r\\n                  \u003c\u003c std::setw(10) \u003c\u003c (order.type == OrderType::MARKET ? \\\"MARKET\\\" : \\\"LIMIT\\\")\\r\\n                  \u003c\u003c std::setw(12) \u003c\u003c std::fixed \u003c\u003c std::setprecision(2) \u003c\u003c order.price\\r\\n                  \u003c\u003c std::setw(12) \u003c\u003c order.quantity\\r\\n                  \u003c\u003c std::setw(10) \u003c\u003c \\\"NEW\\\" \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid UIManager::draw_menu(const std::vector\u003cstd::string\u003e\u0026 options) {\\r\\n    for (const auto\u0026 option : options) {\\r\\n        std::cout \u003c\u003c option \u003c\u003c \\\"\\\\\\\\n\\\";\\r\\n    }\\r\\n}\\r\\n\\r\\nbool UIManager::validate_price_input(const std::string\u0026 input) {\\r\\n    try {\\r\\n        double price = std::stod(input);\\r\\n        return price \u003e 0.0;\\r\\n    } catch (...) {\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\nbool UIManager::validate_quantity_input(const std::string\u0026 input) {\\r\\n    try {\\r\\n        double quantity = std::stod(input);\\r\\n        return quantity \u003e 0.0;\\r\\n    } catch (...) {\\r\\n        return false;\\r\\n    }\\r\\n}\\r\\n\\r\\n} // namespace hft\\r\\n"
                  },
                  {
                      "size":  2082,
                      "relativePath":  "src\\websocket_client.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "src",
                      "fileName":  "websocket_client.cpp",
                      "type":  "source",
                      "content":  "#include \\\"hft/websocket_client.h\\\"\\r\\n#include \u003cnlohmann/json.hpp\u003e\\r\\n\\r\\nnamespace hft {\\r\\n\\r\\n    WebsocketClient::WebsocketClient(MatchingEngine\u0026 engine, std::string symbol)\\r\\n        : engine_(engine), symbol_(symbol) {\\r\\n\\r\\n        uri_ = \\\"wss://stream.binance.com:9443/ws/\\\" + symbol_ + \\\"@depth20@100ms\\\";\\r\\n\\r\\n        ws_client_.init_asio();\\r\\n        ws_client_.set_tls_init_handler([](websocketpp::connection_hdl){\\r\\n            return std::make_shared\u003cboost::asio::ssl::context\u003e(boost::asio::ssl::context::sslv23);\\r\\n        });\\r\\n\\r\\n        ws_client_.set_message_handler(\\r\\n            std::bind(\u0026WebsocketClient::on_message, this,\\r\\n                      std::placeholders::_1, std::placeholders::_2)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    void WebsocketClient::run() {\\r\\n        websocketpp::lib::error_code ec;\\r\\n        client::connection_ptr con = ws_client_.get_connection(uri_, ec);\\r\\n        if (ec) {\\r\\n            std::cout \u003c\u003c \\\"Could not create connection: \\\" \u003c\u003c ec.message() \u003c\u003c std::endl;\\r\\n            return;\\r\\n        }\\r\\n        ws_client_.connect(con);\\r\\n        ws_client_.run();\\r\\n    }\\r\\n\\r\\n    void WebsocketClient::on_message(websocketpp::connection_hdl hdl, client::message_ptr msg) {\\r\\n        auto json = nlohmann::json::parse(msg-\u003eget_payload());\\r\\n\\r\\n        Command cmd;\\r\\n        cmd.type = CommandType::MARKET_DATA;\\r\\n        cmd.timestamp_ns = std::chrono::duration_cast\u003cstd::chrono::nanoseconds\u003e(\\r\\n            std::chrono::system_clock::now().time_since_epoch()\\r\\n        ).count();\\r\\n\\r\\n        for (const auto\u0026 bid : json[\\\"bids\\\"]) {\\r\\n            cmd.bids.push_back({\\r\\n                price_to_int(std::stod(bid[0].get\u003cstd::string\u003e())),\\r\\n                (Quantity)std::stod(bid[1].get\u003cstd::string\u003e())\\r\\n            });\\r\\n        }\\r\\n\\r\\n        for (const auto\u0026 ask : json[\\\"asks\\\"]) {\\r\\n            cmd.asks.push_back({\\r\\n                price_to_int(std::stod(ask[0].get\u003cstd::string\u003e())),\\r\\n                (Quantity)std::stod(ask[1].get\u003cstd::string\u003e())\\r\\n            });\\r\\n        }\\r\\n\\r\\n        while (!engine_.post_command(std::move(cmd))) {\\r\\n            // Spin if the queue is full\\r\\n        }\\r\\n    }\\r\\n}"
                  },
                  {
                      "size":  320,
                      "relativePath":  "tests\\CMakeLists.txt",
                      "extension":  ".txt",
                      "lastModified":  "2025-07-10 13:57:39",
                      "directory":  "tests",
                      "fileName":  "CMakeLists.txt",
                      "type":  "cmake",
                      "content":  "find_package(GTest REQUIRED)\\r\\ninclude(GoogleTest)\\r\\n\\r\\nadd_executable(hft_tests\\r\\n    test_order_book.cpp\\r\\n    test_auth_manager.cpp\\r\\n    test_trading_client.cpp\\r\\n)\\r\\n\\r\\ntarget_link_libraries(hft_tests\\r\\n        PRIVATE\\r\\n        GTest::gtest\\r\\n        GTest::gtest_main\\r\\n        hft_core\\r\\n)\\r\\n\\r\\ngtest_discover_tests(hft_tests)\\r\\n"
                  },
                  {
                      "size":  7601,
                      "relativePath":  "tests\\test_auth_manager.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-10 14:02:47",
                      "directory":  "tests",
                      "fileName":  "test_auth_manager.cpp",
                      "type":  "source",
                      "content":  "#include \u003cgtest/gtest.h\u003e\\r\\n#include \\\"hft/auth_manager.h\\\"\\r\\n#include \u003cfstream\u003e\\r\\n#include \u003ccstdlib\u003e\\r\\n#include \u003cthread\u003e\\r\\n#include \u003cchrono\u003e\\r\\n\\r\\nclass AuthManagerTest : public ::testing::Test {\\r\\nprotected:\\r\\n    void SetUp() override {\\r\\n        auth_manager = std::make_unique\u003chft::AuthManager\u003e();\\r\\n        \\r\\n        // Clean environment variables\\r\\n#ifdef _WIN32\\r\\n        _putenv(\\\"BINANCE_API_KEY=\\\");\\r\\n        _putenv(\\\"BINANCE_SECRET_KEY=\\\");\\r\\n#else\\r\\n        unsetenv(\\\"BINANCE_API_KEY\\\");\\r\\n        unsetenv(\\\"BINANCE_SECRET_KEY\\\");\\r\\n#endif\\r\\n        \\r\\n        // Create test config file\\r\\n        test_config_file = \\\"test_auth_config.json\\\";\\r\\n        std::ofstream file(test_config_file);\\r\\n        file \u003c\u003c R\\\"({\\r\\n            \\\"api_key\\\": \\\"testApiKey12345678901234567890123456789012345678901234567890\\\",\\r\\n            \\\"secret_key\\\": \\\"testSecretKey123456789012345678901234567890123456789012345\\\"\\r\\n        })\\\";\\r\\n        file.close();\\r\\n        \\r\\n        invalid_config_file = \\\"invalid_auth_config.json\\\";\\r\\n        std::ofstream invalid_file(invalid_config_file);\\r\\n        invalid_file \u003c\u003c R\\\"({\\r\\n            \\\"api_key\\\": \\\"short\\\",\\r\\n            \\\"secret_key\\\": \\\"alsoshort\\\"\\r\\n        })\\\";\\r\\n        invalid_file.close();\\r\\n    }\\r\\n\\r\\n    void TearDown() override {\\r\\n        // Clean up test files\\r\\n        std::remove(test_config_file.c_str());\\r\\n        std::remove(invalid_config_file.c_str());\\r\\n    }\\r\\n\\r\\n    std::unique_ptr\u003chft::AuthManager\u003e auth_manager;\\r\\n    std::string test_config_file;\\r\\n    std::string invalid_config_file;\\r\\n};\\r\\n\\r\\nTEST_F(AuthManagerTest, InitialState) {\\r\\n    EXPECT_FALSE(auth_manager-\u003evalidate_credentials());\\r\\n    EXPECT_FALSE(auth_manager-\u003eget_credentials().has_value());\\r\\n    EXPECT_FALSE(auth_manager-\u003etest_connection());\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, SetValidCredentials) {\\r\\n    std::string valid_api_key = \\\"testApiKey12345678901234567890123456789012345678901234567890\\\";\\r\\n    std::string valid_secret = \\\"testSecretKey123456789012345678901234567890123456789012345\\\";\\r\\n    \\r\\n    EXPECT_TRUE(auth_manager-\u003eset_credentials(valid_api_key, valid_secret));\\r\\n    EXPECT_TRUE(auth_manager-\u003evalidate_credentials());\\r\\n    \\r\\n    auto credentials = auth_manager-\u003eget_credentials();\\r\\n    ASSERT_TRUE(credentials.has_value());\\r\\n    EXPECT_EQ(credentials-\u003eapi_key, valid_api_key);\\r\\n    EXPECT_EQ(credentials-\u003esecret_key, valid_secret);\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, SetInvalidCredentials) {\\r\\n    // Test short API key\\r\\n    EXPECT_FALSE(auth_manager-\u003eset_credentials(\\\"short\\\", \\\"validSecretKey123456789012345678901234567890123456789012345\\\"));\\r\\n    \\r\\n    // Test short secret key\\r\\n    EXPECT_FALSE(auth_manager-\u003eset_credentials(\\\"validApiKey12345678901234567890123456789012345678901234567890\\\", \\\"short\\\"));\\r\\n    \\r\\n    // Test invalid characters\\r\\n    EXPECT_FALSE(auth_manager-\u003eset_credentials(\\\"invalid@key#\\\", \\\"validSecretKey123456789012345678901234567890123456789012345\\\"));\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, LoadFromValidConfigFile) {\\r\\n    EXPECT_TRUE(auth_manager-\u003eload_credentials_from_file(test_config_file));\\r\\n    EXPECT_TRUE(auth_manager-\u003evalidate_credentials());\\r\\n    \\r\\n    auto credentials = auth_manager-\u003eget_credentials();\\r\\n    ASSERT_TRUE(credentials.has_value());\\r\\n    EXPECT_EQ(credentials-\u003eapi_key, \\\"testApiKey12345678901234567890123456789012345678901234567890\\\");\\r\\n    EXPECT_EQ(credentials-\u003esecret_key, \\\"testSecretKey123456789012345678901234567890123456789012345\\\");\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, LoadFromInvalidConfigFile) {\\r\\n    EXPECT_FALSE(auth_manager-\u003eload_credentials_from_file(invalid_config_file));\\r\\n    EXPECT_FALSE(auth_manager-\u003evalidate_credentials());\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, LoadFromNonexistentFile) {\\r\\n    EXPECT_FALSE(auth_manager-\u003eload_credentials_from_file(\\\"nonexistent.json\\\"));\\r\\n    EXPECT_FALSE(auth_manager-\u003evalidate_credentials());\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, GenerateSignature) {\\r\\n    std::string query_string = \\\"symbol=BTCUSDT\u0026side=BUY\u0026type=LIMIT\u0026timeInForce=GTC\u0026quantity=1\u0026price=9000\u0026recvWindow=5000\u0026timestamp=1499827319559\\\";\\r\\n    std::string secret = \\\"NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j\\\";\\r\\n    \\r\\n    std::string signature = auth_manager-\u003egenerate_signature(query_string, secret);\\r\\n    EXPECT_FALSE(signature.empty());\\r\\n    EXPECT_EQ(signature.length(), 64); // SHA256 hex string length\\r\\n    \\r\\n    // Test consistency\\r\\n    std::string signature2 = auth_manager-\u003egenerate_signature(query_string, secret);\\r\\n    EXPECT_EQ(signature, signature2);\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, GetTimestamp) {\\r\\n    std::string timestamp1 = auth_manager-\u003eget_timestamp();\\r\\n    std::this_thread::sleep_for(std::chrono::milliseconds(10));\\r\\n    std::string timestamp2 = auth_manager-\u003eget_timestamp();\\r\\n    \\r\\n    EXPECT_FALSE(timestamp1.empty());\\r\\n    EXPECT_FALSE(timestamp2.empty());\\r\\n    EXPECT_NE(timestamp1, timestamp2);\\r\\n    \\r\\n    // Verify timestamp is numeric\\r\\n    EXPECT_NO_THROW(std::stoull(timestamp1));\\r\\n    EXPECT_NO_THROW(std::stoull(timestamp2));\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, ClearCredentials) {\\r\\n    // Set credentials first\\r\\n    auth_manager-\u003eset_credentials(\\r\\n        \\\"testApiKey12345678901234567890123456789012345678901234567890\\\",\\r\\n        \\\"testSecretKey123456789012345678901234567890123456789012345\\\"\\r\\n    );\\r\\n    EXPECT_TRUE(auth_manager-\u003evalidate_credentials());\\r\\n    \\r\\n    // Clear credentials\\r\\n    auth_manager-\u003eclear_credentials();\\r\\n    EXPECT_FALSE(auth_manager-\u003evalidate_credentials());\\r\\n    EXPECT_FALSE(auth_manager-\u003eget_credentials().has_value());\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, TestConnection) {\\r\\n    // Without credentials\\r\\n    EXPECT_FALSE(auth_manager-\u003etest_connection());\\r\\n    \\r\\n    // With valid credentials\\r\\n    auth_manager-\u003eset_credentials(\\r\\n        \\\"testApiKey12345678901234567890123456789012345678901234567890\\\",\\r\\n        \\\"testSecretKey123456789012345678901234567890123456789012345\\\"\\r\\n    );\\r\\n    EXPECT_TRUE(auth_manager-\u003etest_connection());\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, LoadFromEnvironmentVariables) {\\r\\n    // Set environment variables\\r\\n#ifdef _WIN32\\r\\n    _putenv(\\\"BINANCE_API_KEY=envApiKey12345678901234567890123456789012345678901234567890\\\");\\r\\n    _putenv(\\\"BINANCE_SECRET_KEY=envSecretKey123456789012345678901234567890123456789012345\\\");\\r\\n#else\\r\\n    setenv(\\\"BINANCE_API_KEY\\\", \\\"envApiKey12345678901234567890123456789012345678901234567890\\\", 1);\\r\\n    setenv(\\\"BINANCE_SECRET_KEY\\\", \\\"envSecretKey123456789012345678901234567890123456789012345\\\", 1);\\r\\n#endif\\r\\n    \\r\\n    EXPECT_TRUE(auth_manager-\u003eload_credentials());\\r\\n    EXPECT_TRUE(auth_manager-\u003evalidate_credentials());\\r\\n    \\r\\n    auto credentials = auth_manager-\u003eget_credentials();\\r\\n    ASSERT_TRUE(credentials.has_value());\\r\\n    EXPECT_EQ(credentials-\u003eapi_key, \\\"envApiKey12345678901234567890123456789012345678901234567890\\\");\\r\\n    EXPECT_EQ(credentials-\u003esecret_key, \\\"envSecretKey123456789012345678901234567890123456789012345\\\");\\r\\n    \\r\\n    // Clean up\\r\\n    unsetenv(\\\"BINANCE_API_KEY\\\");\\r\\n    unsetenv(\\\"BINANCE_SECRET_KEY\\\");\\r\\n}\\r\\n\\r\\nTEST_F(AuthManagerTest, LoadCredentialsFallback) {\\r\\n    // No environment variables, should fallback to config file\\r\\n    EXPECT_TRUE(auth_manager-\u003eload_credentials_from_file(test_config_file));\\r\\n    \\r\\n    // Create auth_config.json for the load_credentials() method\\r\\n    std::ofstream file(\\\"auth_config.json\\\");\\r\\n    file \u003c\u003c R\\\"({\\r\\n        \\\"api_key\\\": \\\"configApiKey12345678901234567890123456789012345678901234567890\\\",\\r\\n        \\\"secret_key\\\": \\\"configSecretKey123456789012345678901234567890123456789012345\\\"\\r\\n    })\\\";\\r\\n    file.close();\\r\\n    \\r\\n    // Clear current credentials\\r\\n    auth_manager-\u003eclear_credentials();\\r\\n    \\r\\n    // Load should fallback to config file\\r\\n    EXPECT_TRUE(auth_manager-\u003eload_credentials());\\r\\n    \\r\\n    // Clean up\\r\\n    std::remove(\\\"auth_config.json\\\");\\r\\n}\\r\\n"
                  },
                  {
                      "size":  467,
                      "relativePath":  "tests\\test_order_book.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-09 21:04:03",
                      "directory":  "tests",
                      "fileName":  "test_order_book.cpp",
                      "type":  "source",
                      "content":  "#include \u003cgtest/gtest.h\u003e\\r\\n#include \\\"hft/order_book.h\\\"\\r\\n\\r\\nTEST(OrderBookTest, UpdateAndPrint) {\\r\\n    hft::OrderBook book;\\r\\n    hft::Command cmd;\\r\\n    cmd.type = hft::CommandType::MARKET_DATA;\\r\\n    cmd.bids.push_back({hft::price_to_int(100.50), 10});\\r\\n    cmd.asks.push_back({hft::price_to_int(100.55), 5});\\r\\n\\r\\n    book.update(cmd);\\r\\n\\r\\n    // In a real test, you\u0027d capture stdout or check internal state.\\r\\n    // Here we just ensure it doesn\u0027t crash.\\r\\n    SUCCEED();\\r\\n}"
                  },
                  {
                      "size":  10866,
                      "relativePath":  "tests\\test_trading_client.cpp",
                      "extension":  ".cpp",
                      "lastModified":  "2025-07-10 13:49:15",
                      "directory":  "tests",
                      "fileName":  "test_trading_client.cpp",
                      "type":  "source",
                      "content":  "#include \u003cgtest/gtest.h\u003e\\r\\n#include \\\"hft/trading_client.h\\\"\\r\\n#include \\\"hft/auth_manager.h\\\"\\r\\n#include \u003cmemory\u003e\\r\\n#include \u003cchrono\u003e\\r\\n#include \u003cthread\u003e\\r\\n\\r\\nclass TradingClientTest : public ::testing::Test {\\r\\nprotected:\\r\\n    void SetUp() override {\\r\\n        auth_manager = std::make_shared\u003chft::AuthManager\u003e();\\r\\n        auth_manager-\u003eset_credentials(\\r\\n            \\\"testApiKey12345678901234567890123456789012345678901234567890\\\",\\r\\n            \\\"testSecretKey123456789012345678901234567890123456789012345\\\"\\r\\n        );\\r\\n        \\r\\n        trading_client = std::make_unique\u003chft::TradingClient\u003e(auth_manager);\\r\\n        \\r\\n        // Set up callbacks for testing\\r\\n        order_callback_called = false;\\r\\n        trade_callback_called = false;\\r\\n        error_callback_called = false;\\r\\n        last_error_message = \\\"\\\";\\r\\n        \\r\\n        trading_client-\u003eset_order_callback([this](const hft::Order\u0026 order) {\\r\\n            order_callback_called = true;\\r\\n            last_order = order;\\r\\n        });\\r\\n        \\r\\n        trading_client-\u003eset_trade_callback([this](const hft::Trade\u0026 trade) {\\r\\n            trade_callback_called = true;\\r\\n            last_trade = trade;\\r\\n        });\\r\\n        \\r\\n        trading_client-\u003eset_error_callback([this](const std::string\u0026 error) {\\r\\n            error_callback_called = true;\\r\\n            last_error_message = error;\\r\\n        });\\r\\n    }\\r\\n\\r\\n    void TearDown() override {\\r\\n        if (trading_client \u0026\u0026 trading_client-\u003eis_connected()) {\\r\\n            trading_client-\u003edisconnect();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    std::shared_ptr\u003chft::AuthManager\u003e auth_manager;\\r\\n    std::unique_ptr\u003chft::TradingClient\u003e trading_client;\\r\\n    \\r\\n    // Callback tracking\\r\\n    bool order_callback_called;\\r\\n    bool trade_callback_called;\\r\\n    bool error_callback_called;\\r\\n    std::string last_error_message;\\r\\n    hft::Order last_order;\\r\\n    hft::Trade last_trade;\\r\\n};\\r\\n\\r\\nTEST_F(TradingClientTest, InitialState) {\\r\\n    EXPECT_FALSE(trading_client-\u003eis_connected());\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, ConnectWithValidCredentials) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    EXPECT_TRUE(trading_client-\u003eis_connected());\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, ConnectWithoutCredentials) {\\r\\n    auto no_auth_manager = std::make_shared\u003chft::AuthManager\u003e();\\r\\n    auto no_auth_client = std::make_unique\u003chft::TradingClient\u003e(no_auth_manager);\\r\\n    \\r\\n    EXPECT_FALSE(no_auth_client-\u003econnect());\\r\\n    EXPECT_FALSE(no_auth_client-\u003eis_connected());\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, DisconnectAndReconnect) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    EXPECT_TRUE(trading_client-\u003eis_connected());\\r\\n    \\r\\n    trading_client-\u003edisconnect();\\r\\n    EXPECT_FALSE(trading_client-\u003eis_connected());\\r\\n    \\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    EXPECT_TRUE(trading_client-\u003eis_connected());\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, PlaceValidOrder) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    \\r\\n    // Wait for the async operation to complete\\r\\n    auto order_id = future.get();\\r\\n    \\r\\n    EXPECT_FALSE(order_id.empty());\\r\\n    EXPECT_TRUE(order_callback_called);\\r\\n    EXPECT_EQ(last_order.symbol, \\\"BTCUSDT\\\");\\r\\n    EXPECT_EQ(last_order.side, hft::Side::BUY);\\r\\n    EXPECT_EQ(last_order.type, hft::OrderType::LIMIT);\\r\\n    EXPECT_EQ(last_order.price, 45000.0);\\r\\n    EXPECT_EQ(last_order.quantity, 0.001);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, PlaceOrderWithoutConnection) {\\r\\n    auto future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    \\r\\n    auto order_id = future.get();\\r\\n    \\r\\n    EXPECT_TRUE(order_id.empty());\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n    EXPECT_FALSE(order_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, PlaceInvalidOrder) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Invalid price (negative)\\r\\n    auto future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, -45000.0, 0.001);\\r\\n    \\r\\n    auto order_id = future.get();\\r\\n    \\r\\n    EXPECT_TRUE(order_id.empty());\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n    EXPECT_FALSE(order_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, CancelValidOrder) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Place an order first\\r\\n    auto place_future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    auto order_id = place_future.get();\\r\\n    EXPECT_FALSE(order_id.empty());\\r\\n    \\r\\n    // Reset callback flag\\r\\n    order_callback_called = false;\\r\\n    \\r\\n    // Cancel the order\\r\\n    auto cancel_future = trading_client-\u003ecancel_order(order_id);\\r\\n    bool success = cancel_future.get();\\r\\n    \\r\\n    EXPECT_TRUE(success);\\r\\n    EXPECT_TRUE(order_callback_called);\\r\\n    EXPECT_EQ(last_order.status, hft::OrderStatus::CANCELED);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, CancelNonexistentOrder) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto future = trading_client-\u003ecancel_order(\\\"NONEXISTENT_ORDER\\\");\\r\\n    bool success = future.get();\\r\\n    \\r\\n    EXPECT_FALSE(success);\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, CancelOrderWithoutConnection) {\\r\\n    auto future = trading_client-\u003ecancel_order(\\\"ORDER_123456\\\");\\r\\n    bool success = future.get();\\r\\n    \\r\\n    EXPECT_FALSE(success);\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetOpenOrders) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Place some orders\\r\\n    auto future1 = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    auto future2 = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::SELL, hft::OrderType::LIMIT, 46000.0, 0.001);\\r\\n    \\r\\n    future1.get();\\r\\n    future2.get();\\r\\n    \\r\\n    // Get open orders\\r\\n    auto orders_future = trading_client-\u003eget_open_orders(\\\"BTCUSDT\\\");\\r\\n    auto orders = orders_future.get();\\r\\n    \\r\\n    EXPECT_EQ(orders.size(), 2);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetOpenOrdersEmptySymbol) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto orders_future = trading_client-\u003eget_open_orders(\\\"\\\");\\r\\n    auto orders = orders_future.get();\\r\\n    \\r\\n    EXPECT_TRUE(orders.empty());\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetAccountBalance) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto balance_future = trading_client-\u003eget_account_balance(\\\"USDT\\\");\\r\\n    double balance = balance_future.get();\\r\\n    \\r\\n    EXPECT_GT(balance, 0.0);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetCurrentPrice) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto price_future = trading_client-\u003eget_current_price(\\\"BTCUSDT\\\");\\r\\n    double price = price_future.get();\\r\\n    \\r\\n    EXPECT_GT(price, 0.0);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetBidAskSpread) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto spread_future = trading_client-\u003eget_bid_ask_spread(\\\"BTCUSDT\\\");\\r\\n    auto spread = spread_future.get();\\r\\n    \\r\\n    EXPECT_GT(spread.first, 0.0);  // bid\\r\\n    EXPECT_GT(spread.second, 0.0); // ask\\r\\n    EXPECT_LT(spread.first, spread.second); // bid \u003c ask\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, RiskManagementMaxOrderValue) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    trading_client-\u003eset_max_order_value(1000.0);\\r\\n    \\r\\n    // Try to place order with value \u003e max_order_value\\r\\n    auto future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 1.0); // 45000 \u003e 1000\\r\\n    \\r\\n    auto order_id = future.get();\\r\\n    \\r\\n    EXPECT_TRUE(order_id.empty());\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, RiskManagementMaxPositionSize) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    trading_client-\u003eset_max_position_size(\\\"BTCUSDT\\\", 0.01);\\r\\n    \\r\\n    // Try to place order with quantity \u003e max_position_size\\r\\n    auto future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.1);\\r\\n    \\r\\n    auto order_id = future.get();\\r\\n    \\r\\n    EXPECT_TRUE(order_id.empty());\\r\\n    EXPECT_TRUE(error_callback_called);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, OrderValidation) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Valid order\\r\\n    EXPECT_TRUE(trading_client-\u003evalidate_order(\\\"BTCUSDT\\\", hft::Side::BUY, 45000.0, 0.001));\\r\\n    \\r\\n    // Invalid price\\r\\n    EXPECT_FALSE(trading_client-\u003evalidate_order(\\\"BTCUSDT\\\", hft::Side::BUY, -45000.0, 0.001));\\r\\n    EXPECT_FALSE(trading_client-\u003evalidate_order(\\\"BTCUSDT\\\", hft::Side::BUY, 0.0, 0.001));\\r\\n    \\r\\n    // Invalid quantity\\r\\n    EXPECT_FALSE(trading_client-\u003evalidate_order(\\\"BTCUSDT\\\", hft::Side::BUY, 45000.0, 0.0));\\r\\n    EXPECT_FALSE(trading_client-\u003evalidate_order(\\\"BTCUSDT\\\", hft::Side::BUY, 45000.0, -0.001));\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, CancelAllOrders) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Place multiple orders\\r\\n    auto future1 = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    auto future2 = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::SELL, hft::OrderType::LIMIT, 46000.0, 0.001);\\r\\n    auto future3 = trading_client-\u003eplace_order(\\\"ETHUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 3000.0, 0.01);\\r\\n    \\r\\n    future1.get();\\r\\n    future2.get();\\r\\n    future3.get();\\r\\n    \\r\\n    // Cancel all BTCUSDT orders\\r\\n    auto cancel_future = trading_client-\u003ecancel_all_orders(\\\"BTCUSDT\\\");\\r\\n    bool success = cancel_future.get();\\r\\n    \\r\\n    EXPECT_TRUE(success);\\r\\n    \\r\\n    // Check remaining orders\\r\\n    auto orders_future = trading_client-\u003eget_open_orders(\\\"\\\");\\r\\n    auto orders = orders_future.get();\\r\\n    \\r\\n    // Should only have ETHUSDT order remaining\\r\\n    EXPECT_EQ(orders.size(), 1);\\r\\n    EXPECT_EQ(orders[0].symbol, \\\"ETHUSDT\\\");\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetOrderStatus) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    // Place an order\\r\\n    auto place_future = trading_client-\u003eplace_order(\\\"BTCUSDT\\\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);\\r\\n    auto order_id = place_future.get();\\r\\n    EXPECT_FALSE(order_id.empty());\\r\\n    \\r\\n    // Get order status\\r\\n    auto status_future = trading_client-\u003eget_order_status(order_id);\\r\\n    auto order = status_future.get();\\r\\n    \\r\\n    EXPECT_EQ(order.id, order_id);\\r\\n    EXPECT_EQ(order.symbol, \\\"BTCUSDT\\\");\\r\\n    EXPECT_EQ(order.side, hft::Side::BUY);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetOrderStatusNonexistent) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto status_future = trading_client-\u003eget_order_status(\\\"NONEXISTENT_ORDER\\\");\\r\\n    auto order = status_future.get();\\r\\n    \\r\\n    EXPECT_EQ(order.status, hft::OrderStatus::REJECTED);\\r\\n}\\r\\n\\r\\nTEST_F(TradingClientTest, GetTradeHistory) {\\r\\n    EXPECT_TRUE(trading_client-\u003econnect());\\r\\n    \\r\\n    auto trades_future = trading_client-\u003eget_trade_history(\\\"BTCUSDT\\\", 10);\\r\\n    auto trades = trades_future.get();\\r\\n    \\r\\n    // For mock implementation, should return empty vector\\r\\n    EXPECT_TRUE(trades.empty());\\r\\n}\\r\\n"
                  }
              ]
}
