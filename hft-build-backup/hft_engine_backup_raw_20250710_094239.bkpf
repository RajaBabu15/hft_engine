{
  "metadata": {
    "projectName": "hft_engine",
    "backupDate": "2025-07-10 09:42:42",
    "projectRoot": "/mnt/c/Users/rajab/CLionProjects/hft_engine",
    "fileCount": 30,
    "backupVersion": "1.0",
    "generatedBy": "HFT Engine Raw Content Backup Script (Bash/WSL)"
  },
  "files": [
    {
      "directory": "",
      "fileName": "CMakeLists.txt",
      "extension": ".txt",
      "type": "cmake",
      "relativePath": "CMakeLists.txt",
      "size": 1735,
      "lastModified": "2025-07-10 08:27:30",
      "content": "cmake_minimum_required(VERSION 3.16)
project(HFTEngine CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pthread\")

# Enable coverage reporting
option(ENABLE_COVERAGE \"Enable code coverage reporting\" OFF)
if(ENABLE_COVERAGE)
    set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} --coverage -fprofile-arcs -ftest-coverage\")
    set(CMAKE_EXE_LINKER_FLAGS \"${CMAKE_EXE_LINKER_FLAGS} --coverage\")
endif()

# --- External Dependencies ---
find_package(Boost 1.74 REQUIRED COMPONENTS system thread)
find_package(OpenSSL REQUIRED)
find_package(nlohmann_json 3.2.0 REQUIRED)

# --- Vendored WebSocket++ (compatible v0.8.2) ---
add_library(websocketpp INTERFACE)
# CORRECTED: Point to the directory CONTAINING the websocketpp folder
target_include_directories(websocketpp INTERFACE
        ${CMAKE_SOURCE_DIR}/external/websocketpp
)

# --- Core Engine Library ---
add_library(hft_core
        src/matching_engine.cpp
        src/order_book.cpp
        src/websocket_client.cpp
        src/auth_manager.cpp
        src/trading_client.cpp
        src/ui_manager.cpp
)

# Public headers for hft_core
target_include_directories(hft_core PUBLIC
        $<BUILD_INTERFACE:${CMAKE_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:include>
)

# Link in Boost, OpenSSL, JSON, and our vendored wspp
target_link_libraries(hft_core
        PUBLIC
        Boost::system
        Boost::thread
        OpenSSL::SSL
        OpenSSL::Crypto
        nlohmann_json::nlohmann_json
        websocketpp
)

# --- Main Executable ---
add_executable(hft_engine
        src/main.cpp
)
target_link_libraries(hft_engine
        PRIVATE
        hft_core
)

# --- Testing Setup ---
enable_testing()
add_subdirectory(tests)"
    },
    {
      "directory": "",
      "fileName": "config.json",
      "extension": ".json",
      "type": "configuration",
      "relativePath": "config.json",
      "size": 48,
      "lastModified": "2025-07-09 15:34:03",
      "content": "{
  \"symbol\": \"btcusdt\",
  \"book_depth\": 10
}"
    },
    {
      "directory": "",
      "fileName": "Dockerfile",
      "extension": "",
      "type": "special",
      "relativePath": "Dockerfile",
      "size": 758,
      "lastModified": "2025-07-09 15:34:03",
      "content": "# Stage 1: Builder
FROM ubuntu:22.04 AS builder
RUN apt-get update && apt-get install -y \\
    build-essential \\
    cmake \\
    git \\
    libssl-dev \\
    libboost-system-dev \\
    libboost-thread-dev \\
    nlohmann-json3-dev

# Clone and build websocketpp
RUN git clone https://github.com/zaphoyd/websocketpp.git /websocketpp

WORKDIR /app
COPY . .
RUN mkdir build && cd build && \\
    cmake -DCMAKE_PREFIX_PATH=/websocketpp .. && \\
    make -j$(nproc)

# Stage 2: Runner
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y libssl3 libboost-system1.74.0 libboost-thread1.74.0 && rm -rf /var/lib/apt/lists/*
WORKDIR /app
COPY --from=builder /app/build/hft_engine .
COPY --from=builder /app/config.json .
CMD [\"./hft_engine\"]"
    },
    {
      "directory": "include/hft",
      "fileName": "auth_manager.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/auth_manager.h",
      "size": 1658,
      "lastModified": "2025-07-10 08:13:22",
      "content": "#pragma once
#include <string>
#include <optional>
#include <memory>

namespace hft {
    class AuthManager {
    public:
        struct Credentials {
            std::string api_key;
            std::string secret_key;
            std::string passphrase; // For some exchanges
        };

        AuthManager();
        ~AuthManager();

        // Load credentials from environment variables or config file
        bool load_credentials();
        bool load_credentials_from_file(const std::string& config_path);
        bool set_credentials(const std::string& api_key, const std::string& secret_key);
        
        // Validate credentials format
        bool validate_credentials() const;
        
        // Get credentials (returns nullopt if not loaded)
        std::optional<Credentials> get_credentials() const;
        
        // Generate HMAC signature for API requests
        std::string generate_signature(const std::string& query_string, const std::string& secret) const;
        
        // Generate timestamp for API requests
        std::string get_timestamp() const;
        
        // Clear credentials from memory
        void clear_credentials();
        
        // Test connection with current credentials
        bool test_connection() const;

    private:
        bool credentials_loaded_;
        std::unique_ptr<Credentials> credentials_;
        
        // Helper methods
        bool is_valid_api_key(const std::string& key) const;
        bool is_valid_secret(const std::string& secret) const;
        std::string read_from_env(const std::string& var_name) const;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "command.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/command.h",
      "size": 466,
      "lastModified": "2025-07-10 08:32:00",
      "content": "#pragma once
#include \"types.h\"
#include <cstdint>
#include <string>
#include <vector>

namespace hft {
    enum class CommandType { MARKET_DATA };

    struct Level {
        Price price;
        Quantity quantity;
    };

    // Padded to a cache line to prevent false sharing
    struct alignas(64) Command {
        CommandType type;
        uint64_t timestamp_ns;
        std::vector<Level> bids;
        std::vector<Level> asks;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "common.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/common.h",
      "size": 478,
      "lastModified": "2025-07-10 08:17:25",
      "content": "#pragma once
#include <cstdint>
#include <string>

namespace hft {
    // Legacy types for backward compatibility
    using LegacyPrice = int64_t;
    using LegacyQuantity = uint64_t;
    using OrderID = uint64_t;

    // Convert floating point price to a fixed-point integer
    inline LegacyPrice price_to_int(double p) { return static_cast<LegacyPrice>(p * 100.0); }
    inline double price_to_double(LegacyPrice p) { return static_cast<double>(p) / 100.0; }
}"
    },
    {
      "directory": "include/hft",
      "fileName": "matching_engine.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/matching_engine.h",
      "size": 626,
      "lastModified": "2025-07-09 15:57:21",
      "content": "#pragma once
#include <atomic>
#include <thread>
#include <boost/lockfree/queue.hpp>
#include \"command.h\"
#include \"order_book.h\"

namespace hft {
    class MatchingEngine {
    public:
        MatchingEngine(int book_depth);
        ~MatchingEngine();

        bool post_command(Command&& cmd);
        void run();
        void stop();

    private:
        void writer_thread_func();

        boost::lockfree::queue<Command*> command_queue_{1024 * 64};
        OrderBook order_book_;
        int book_depth_;

        std::atomic<bool> running_{false};
        std::thread writer_thread_;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "order_book.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/order_book.h",
      "size": 381,
      "lastModified": "2025-07-09 15:34:03",
      "content": "#pragma once
#include \"command.h\"
#include <map>
#include <vector>
#include <string>
#include <iostream>

namespace hft {
    class OrderBook {
    public:
        void update(const Command& cmd);
        void print_book(int depth) const;

    private:
        std::map<Price, Quantity, std::greater<Price>> bids_;
        std::map<Price, Quantity> asks_;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "trading_client.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/trading_client.h",
      "size": 3377,
      "lastModified": "2025-07-10 08:13:47",
      "content": "#pragma once
#include \"types.h\"
#include \"auth_manager.h\"
#include <vector>
#include <unordered_map>
#include <functional>
#include <future>
#include <memory>

namespace hft {
    class TradingClient {
    public:
        using OrderCallback = std::function<void(const Order&)>;
        using TradeCallback = std::function<void(const Trade&)>;
        using ErrorCallback = std::function<void(const std::string&)>;

        explicit TradingClient(std::shared_ptr<AuthManager> auth_manager);
        ~TradingClient();

        // Connection management
        bool connect();
        void disconnect();
        bool is_connected() const;

        // Order management
        std::future<OrderId> place_order(const Symbol& symbol, Side side, OrderType type, 
                                       Price price, Quantity quantity, TimeInForce tif = TimeInForce::GTC);
        std::future<bool> cancel_order(const OrderId& order_id);
        std::future<bool> cancel_all_orders(const Symbol& symbol = \"\");
        
        // Account information
        std::future<std::vector<Order>> get_open_orders(const Symbol& symbol = \"\");
        std::future<std::vector<Trade>> get_trade_history(const Symbol& symbol = \"\", int limit = 100);
        std::future<double> get_account_balance(const std::string& asset = \"USDT\");
        
        // Order status queries
        std::future<Order> get_order_status(const OrderId& order_id);
        
        // Callbacks for real-time updates
        void set_order_callback(OrderCallback callback);
        void set_trade_callback(TradeCallback callback);
        void set_error_callback(ErrorCallback callback);
        
        // Risk management
        void set_max_position_size(const Symbol& symbol, Quantity max_size);
        void set_max_order_value(double max_value);
        bool validate_order(const Symbol& symbol, Side side, Price price, Quantity quantity) const;
        
        // Market data requests
        std::future<double> get_current_price(const Symbol& symbol);
        std::future<std::pair<Price, Price>> get_bid_ask_spread(const Symbol& symbol);

    private:
        std::shared_ptr<AuthManager> auth_manager_;
        bool connected_;
        
        // Risk management settings
        std::unordered_map<Symbol, Quantity> max_position_sizes_;
        double max_order_value_;
        
        // Callbacks
        OrderCallback order_callback_;
        TradeCallback trade_callback_;
        ErrorCallback error_callback_;
        
        // Internal order tracking
        std::unordered_map<OrderId, Order> active_orders_;
        
        // HTTP client for REST API calls
        std::string make_authenticated_request(const std::string& endpoint, const std::string& method, 
                                              const std::string& params = \"\");
        
        // Helper methods
        OrderId generate_order_id();
        std::string get_current_timestamp();
        bool check_connection();
        void handle_error(const std::string& error_message);
        
        // Order validation
        bool validate_price(Price price) const;
        bool validate_quantity(Quantity quantity) const;
        bool check_risk_limits(const Symbol& symbol, Side side, Price price, Quantity quantity) const;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "types.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/types.h",
      "size": 1208,
      "lastModified": "2025-07-10 08:13:07",
      "content": "#pragma once
#include <string>
#include <cstdint>

namespace hft {
    using Price = double;
    using Quantity = double;
    using OrderId = std::string;
    using Symbol = std::string;
    using Timestamp = uint64_t;

    enum class Side {
        BUY,
        SELL
    };

    enum class OrderType {
        MARKET,
        LIMIT,
        STOP_LIMIT
    };

    enum class OrderStatus {
        NEW,
        PARTIALLY_FILLED,
        FILLED,
        CANCELED,
        REJECTED,
        EXPIRED
    };

    enum class TimeInForce {
        GTC,  // Good Till Canceled
        IOC,  // Immediate or Cancel
        FOK   // Fill or Kill
    };

    struct Order {
        OrderId id;
        Symbol symbol;
        Side side;
        OrderType type;
        Price price;
        Quantity quantity;
        Quantity filled_quantity = 0.0;
        OrderStatus status = OrderStatus::NEW;
        TimeInForce time_in_force = TimeInForce::GTC;
        Timestamp timestamp;
    };

    struct Trade {
        OrderId order_id;
        Symbol symbol;
        Side side;
        Price price;
        Quantity quantity;
        Timestamp timestamp;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "ui_manager.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/ui_manager.h",
      "size": 3689,
      "lastModified": "2025-07-10 08:14:12",
      "content": "#pragma once
#include \"types.h\"
#include \"order_book.h\"
#include <vector>
#include <string>
#include <memory>
#include <functional>

namespace hft {
    enum class UIMode {
        LOGIN,
        MAIN_MENU,
        ORDER_BOOK_VIEW,
        ORDER_MANAGEMENT,
        ACCOUNT_INFO,
        SETTINGS
    };

    class UIManager {
    public:
        using LoginCallback = std::function<bool(const std::string&, const std::string&)>;
        using OrderCallback = std::function<void(const Symbol&, Side, OrderType, Price, Quantity)>;
        using CancelCallback = std::function<void(const OrderId&)>;

        UIManager();
        ~UIManager();

        // UI lifecycle
        bool initialize();
        void cleanup();
        void run();
        void stop();

        // Mode management
        void set_mode(UIMode mode);
        UIMode get_current_mode() const;

        // Display methods
        void display_login_screen();
        void display_main_menu();
        void display_order_book(const OrderBook& order_book, int depth = 10);
        void display_order_management(const std::vector<Order>& orders);
        void display_account_info(double balance, const std::vector<Trade>& recent_trades);
        void display_error(const std::string& message);
        void display_status(const std::string& message);

        // Input handling
        std::pair<std::string, std::string> get_login_credentials();
        int get_menu_choice(const std::vector<std::string>& options);
        Order get_order_input(const Symbol& symbol);
        std::string get_cancel_order_id();

        // Callbacks
        void set_login_callback(LoginCallback callback);
        void set_order_callback(OrderCallback callback);
        void set_cancel_callback(CancelCallback callback);

        // UI updates
        void update_connection_status(bool connected);
        void update_order_book(const OrderBook& order_book);
        void update_orders(const std::vector<Order>& orders);
        void update_balance(double balance);

        // Utility methods
        void clear_screen();
        void print_header(const std::string& title);
        void print_separator();
        void wait_for_key();

    private:
        UIMode current_mode_;
        bool running_;
        bool initialized_;

        // Callbacks
        LoginCallback login_callback_;
        OrderCallback order_callback_;
        CancelCallback cancel_callback_;

        // Display state
        bool connection_status_;
        std::string last_error_;
        std::string last_status_;

        // Input/output helpers
        std::string get_input(const std::string& prompt);
        double get_numeric_input(const std::string& prompt);
        char get_char_input();
        void print_colored(const std::string& text, const std::string& color);
        
        // Screen drawing
        void draw_border();
        void draw_order_book_table(const OrderBook& order_book, int depth);
        void draw_order_table(const std::vector<Order>& orders);
        void draw_menu(const std::vector<std::string>& options);
        
        // Validation
        bool validate_price_input(const std::string& input);
        bool validate_quantity_input(const std::string& input);
        
        // Color codes for terminal output
        static const std::string RESET;
        static const std::string RED;
        static const std::string GREEN;
        static const std::string YELLOW;
        static const std::string BLUE;
        static const std::string CYAN;
        static const std::string WHITE;
    };
}"
    },
    {
      "directory": "include/hft",
      "fileName": "websocket_client.h",
      "extension": ".h",
      "type": "header",
      "relativePath": "include/hft/websocket_client.h",
      "size": 677,
      "lastModified": "2025-07-09 16:38:12",
      "content": "#pragma once
#include \"matching_engine.h\"
#include <websocketpp/client.hpp>
#include <websocketpp/config/asio_client.hpp>
#include <string>
#include <memory>

namespace hft {

    // Use the standard, default client config
    using client = websocketpp::client<websocketpp::config::asio_tls_client>;

    class WebsocketClient {
    public:
        WebsocketClient(MatchingEngine& engine, std::string symbol);
        void run();

    private:
        void on_message(websocketpp::connection_hdl hdl, client::message_ptr msg);

        MatchingEngine& engine_;
        client ws_client_;
        std::string uri_;
        std::string symbol_;
    };
}"
    },
    {
      "directory": "",
      "fileName": "README.md",
      "extension": ".md",
      "type": "documentation",
      "relativePath": "README.md",
      "size": 7719,
      "lastModified": "2025-07-10 08:06:17",
      "content": "# High-Frequency Trading (HFT) Engine

A professional-grade **High-Frequency Trading Engine** built in C++ that connects to Binance cryptocurrency exchange via WebSocket to receive real-time market data and maintain a live order book for algorithmic trading strategies.

## üéØ Project Overview

This HFT engine demonstrates institutional-grade trading infrastructure with microsecond-level optimizations. It serves as a foundation for:

- **Cryptocurrency Trading Bots**
- **Market Making Algorithms** 
- **Statistical Arbitrage Strategies**
- **Real-time Market Analysis**
- **Backtesting Infrastructure**

## üöÄ What This Project Achieves

1. **Real-time Market Data Processing**: Connects to Binance's WebSocket API for live order book updates
2. **High-Performance Order Book Management**: Maintains accurate, real-time market depth data
3. **Ultra-Low Latency Architecture**: Built for algorithmic trading with microsecond optimizations
4. **Market Analysis Foundation**: Provides real-time market conditions for trading decisions

**‚ö†Ô∏è Important Note**: This is a **READ-ONLY** market data system. It does **NOT** execute actual trades or place orders. It only displays real-time market data for analysis and strategy development.

## üèóÔ∏è Architecture & Components

### Core Components

| Component | File | Purpose |
|-----------|------|----------|
| **WebSocket Client** | `websocket_client.h/cpp` | Real-time connection to Binance API |
| **Matching Engine** | `matching_engine.h/cpp` | High-performance message processor |
| **Order Book** | `order_book.h/cpp` | Market depth data management |
| **Command System** | `command.h` | Internal communication structures |
| **Configuration** | `config.json` | Trading pair and display settings |

### Technical Features

- **Lock-free Programming**: Eliminates thread contention for ultra-low latency
- **Cache Optimization**: 64-byte aligned structures prevent false sharing
- **Asynchronous Processing**: Separates I/O from computation
- **Multi-threading**: Dedicated threads for data reception and processing
- **Memory Efficient**: Optimized STL containers for trading data

## üìä Real-time Output Example

```
Connecting to Binance for symbol: \"btcusdt\"
Press Ctrl+C to exit.
[2025-07-10 07:54:52] [connect] Successful connection

--- ORDER BOOK ---
------------------------------------
|       BIDS       |       ASKS       |
| Price    | Qty     | Price    | Qty     |
------------------------------------
| 111224.58 |       5 | 111224.59 |       2 |
| 111224.57 |       0 | 111224.60 |       0 |
| 111223.89 |       0 | 111225.00 |       0 |
| 111223.88 |       0 | 111226.00 |       0 |
------------------------------------
```

## üîÑ Data Flow Process

1. **WebSocket Connection**: Connects to `wss://stream.binance.com:9443/ws/btcusdt@depth20@100ms`
2. **Data Reception**: Receives order book updates every 100ms
3. **JSON Parsing**: Converts market data to internal command format
4. **Lock-free Queue**: Passes data through ultra-fast message queue
5. **Order Book Update**: Updates bid/ask levels in real-time
6. **Display**: Renders formatted order book to terminal

## ‚ö° Performance Optimizations

- **Lock-free Queue**: Boost's lock-free queue for 64K commands
- **Cache Line Alignment**: Prevents CPU cache false sharing
- **Single Writer Pattern**: Eliminates lock contention
- **Memory Pool**: Reduces allocation overhead
- **Branch Prediction**: Optimized conditional logic

## üìà Trading vs. Display-Only Functionality

### Current State: **DISPLAY-ONLY** üìä

This project is currently a **market data viewer** and does **NOT** execute any actual trading operations. Here's what it does:

**‚úÖ What it DOES:**
- Connects to Binance WebSocket API
- Receives real-time market data
- Displays live order book updates
- Maintains accurate bid/ask spreads
- Provides foundation for trading algorithms

**‚ùå What it does NOT do:**
- Place buy/sell orders
- Execute trades
- Manage positions or portfolio
- Handle authentication for trading
- Risk management or position sizing

### üöÄ Future Trading Extension

To convert this into an actual trading system, you would need to add:

1. **Binance Trading API Integration**
   ```cpp
   // Example: Order placement functionality
   class TradingClient {
       void place_order(Side side, Price price, Quantity qty);
       void cancel_order(OrderId id);
   };
   ```

2. **Authentication & API Keys**
   - Binance API key and secret
   - HMAC signature generation
   - Rate limiting compliance

3. **Trading Strategy Logic**
   ```cpp
   class MarketMakingStrategy {
       void on_order_book_update(const OrderBook& book);
       void place_quotes(Price bid, Price ask);
   };
   ```

4. **Risk Management**
   - Position limits
   - Stop-loss mechanisms
   - Exposure monitoring

### ‚ö†Ô∏è Trading Risks Warning

**IMPORTANT**: Adding actual trading functionality involves significant financial risk:
- Cryptocurrency markets are highly volatile
- Algorithmic trading can lead to rapid losses
- Always test strategies in simulation first
- Never risk more than you can afford to lose
- Consider regulatory compliance in your jurisdiction

## Prerequisites

- Docker
- A C++20 compatible compiler (GCC 11+ or Clang 14+)
- CMake (3.16+)
- Boost libraries (`system`, `thread`)
- OpenSSL
- `nlohmann/json` library

On **Ubuntu 22.04**, you can install C++ dependencies with:
```bash
sudo apt update && sudo apt install -y \\
    build-essential cmake git libssl-dev \\
    libboost-all-dev nlohmann-json3-dev pkg-config
```

## üõ†Ô∏è How to Build and Run

### Method 1: Ubuntu/WSL (Recommended)

1. **Install Dependencies:**
   ```bash
   sudo apt update && sudo apt install -y build-essential cmake libboost-all-dev libssl-dev nlohmann-json3-dev pkg-config git
   ```

2. **Clone Repository & Dependencies:**
   ```bash
   git clone <your-repo-url>
   cd hft_engine
   mkdir -p external && cd external
   git clone https://github.com/zaphoyd/websocketpp.git
   cd ..
   ```

3. **Build Project:**
   ```bash
   mkdir build && cd build
   cmake ..
   make -j4
   ```

4. **Configure Trading Pair:**
   ```bash
   cp ../config.json .
   # Edit config.json to change symbol (default: \"btcusdt\")
   ```

5. **Run the Engine:**
   ```bash
   ./hft_engine
   ```

### Method 2: Windows with WSL

1. **Enable WSL and install Ubuntu:**
   ```powershell
   wsl --install -d Ubuntu-24.04
   ```

2. **Open WSL terminal and follow Method 1 steps above**

3. **Navigate to Windows project folder:**
   ```bash
   cd /mnt/c/Users/[username]/CLionProjects/hft_engine
   ```

### Method 3: Native Windows (Advanced)

1. **Install dependencies via vcpkg or manually**
2. **Use Visual Studio with CMake support**
3. **Configure paths for Boost, OpenSSL, nlohmann_json**

### Expected Output

Successful run shows:
```
Connecting to Binance for symbol: \"btcusdt\"
Press Ctrl+C to exit.
[2025-07-10 07:54:52] [connect] Successful connection
[2025-07-10 07:54:52] [connect] WebSocket Connection 57.182.125.171:9443

--- ORDER BOOK ---
------------------------------------
|       BIDS       |       ASKS       |
| Price    | Qty     | Price    | Qty     |
------------------------------------
| 111224.58 |       5 | 111224.59 |       2 |
...
```

## How to Build and Run (with Docker)

1.  **Build the Docker Image:**
    ```bash
    docker build -t hft-engine .
    ```

2.  **Run the Container:**
    ```bash
    docker run -it --rm hft-engine
    ```"
    },
    {
      "directory": "scripts",
      "fileName": "backup.ps1",
      "extension": ".ps1",
      "type": "script",
      "relativePath": "scripts/backup.ps1",
      "size": 6634,
      "lastModified": "2025-07-10 09:27:00",
      "content": "# HFT Engine Backup Script
# Creates a JSON-formatted backup file (.bkpf) containing all relevant project files

param(
    [string]$OutputPath = \"hft-build-backup\",
    [string]$ProjectName = \"hft_engine\"
)

# Get the project root directory
$ProjectRoot = Split-Path -Parent $PSScriptRoot
$BackupDir = Join-Path $ProjectRoot $OutputPath
$BackupFileName = \"${ProjectName}_backup_$(Get-Date -Format 'yyyyMMdd_HHmmss').bkpf\"
$BackupPath = Join-Path $BackupDir $BackupFileName

Write-Host \"Creating backup for project: $ProjectName\" -ForegroundColor Green
Write-Host \"Project root: $ProjectRoot\" -ForegroundColor Yellow
Write-Host \"Backup directory: $BackupDir\" -ForegroundColor Yellow
Write-Host \"Backup file: $BackupFileName\" -ForegroundColor Yellow

# Create backup directory if it doesn't exist
if (-not (Test-Path $BackupDir)) {
    New-Item -ItemType Directory -Path $BackupDir -Force | Out-Null
    Write-Host \"Created backup directory: $BackupDir\" -ForegroundColor Green
}

# Define file extensions to include
$IncludeExtensions = @(
    '.cpp', '.c', '.cc', '.cxx',     # C++ source files
    '.h', '.hpp', '.hxx',            # Header files
    '.py', '.pyx', '.pyi',           # Python files
    '.cmake', '.txt',                # CMake files
    '.md', '.rst',                   # Documentation
    '.json', '.yaml', '.yml',        # Configuration files
    '.sh', '.bat', '.ps1',           # Scripts
    '.gitignore', '.gitattributes'   # Git files
)

# Define special files to always include
$SpecialFiles = @(
    'CMakeLists.txt',
    'README.md',
    'Dockerfile',
    'Makefile',
    '.gitignore'
)

# Define directories to exclude
$ExcludeDirectories = @(
    'build', 'Build', 'BUILD',
    'cmake-build-debug', 'cmake-build-release',
    '.git', '.svn', '.hg',
    '.idea', '.vscode', '.vs',
    'external', 'third_party', 'deps',
    'node_modules', '__pycache__',
    '.pytest_cache', '.coverage',
    'dist', 'target', 'out',
    'hft-build-backup'
)

# Function to determine file type based on extension
function Get-FileType {
    param($Extension)
    switch ($Extension) {
        { $_ -in @('.cpp', '.c', '.cc', '.cxx') } { return 'source' }
        { $_ -in @('.h', '.hpp', '.hxx') } { return 'header' }
        { $_ -in @('.py', '.pyx', '.pyi') } { return 'python' }
        { $_ -in @('.cmake', '.txt') } { return 'cmake' }
        { $_ -in @('.md', '.rst') } { return 'documentation' }
        { $_ -in @('.json', '.yaml', '.yml') } { return 'configuration' }
        { $_ -in @('.sh', '.bat', '.ps1') } { return 'script' }
        { $_ -in @('.gitignore', '.gitattributes') } { return 'git' }
        { $_ -eq '' } { return 'special' }
        default { return 'other' }
    }
}

# Function to check if directory should be excluded
function Should-ExcludeDirectory {
    param($DirectoryPath)
    foreach ($ExcludeDir in $ExcludeDirectories) {
        if ($DirectoryPath -like \"*$ExcludeDir*\") {
            return $true
        }
    }
    return $false
}

# Function to escape JSON strings
function Escape-JsonString {
    param($InputString)
    if ($null -eq $InputString) { return \"\" }
    $InputString = $InputString -replace '\\\\', '\\\\\\\\'
    $InputString = $InputString -replace '\"', '\\\"'
    $InputString = $InputString -replace \"`n\", '\\n'
    $InputString = $InputString -replace \"`r\", '\\r'
    $InputString = $InputString -replace \"`t\", '\\t'
    return $InputString
}

# Collect all relevant files
$Files = @()
$FileCount = 0

Write-Host \"Scanning for files...\" -ForegroundColor Green

Get-ChildItem -Path $ProjectRoot -Recurse -File | ForEach-Object {
    $File = $_
    $RelativePath = $File.FullName.Substring($ProjectRoot.Length + 1)
    
    # Check if file is in an excluded directory
    if (Should-ExcludeDirectory $RelativePath) {
        return
    }
    
    # Check if file extension is included or if it's a special file
    $Extension = $File.Extension.ToLower()
    $IsIncluded = $IncludeExtensions -contains $Extension -or $SpecialFiles -contains $File.Name
    
    if ($IsIncluded) {
        try {
            $Content = Get-Content -Path $File.FullName -Raw -ErrorAction Stop
            $EscapedContent = Escape-JsonString $Content
            
            $Directory = Split-Path -Path $RelativePath -Parent
            if ([string]::IsNullOrEmpty($Directory)) {
                $Directory = \"\"
            }
            
            $FileInfo = @{
                directory = $Directory
                fileName = $File.Name
                extension = $Extension
                type = Get-FileType $Extension
                relativePath = $RelativePath
                size = $File.Length
                lastModified = $File.LastWriteTime.ToString('yyyy-MM-dd HH:mm:ss')
                content = $EscapedContent
            }
            $Files += $FileInfo
            $FileCount++
            Write-Host \"  Added: $RelativePath\" -ForegroundColor Green
        }
        catch {
            Write-Host \"  Skipped: $RelativePath (binary or inaccessible)\" -ForegroundColor Yellow
        }
    }
}

# Create backup object
$BackupData = @{
    metadata = @{
        projectName = $ProjectName
        backupDate = Get-Date -Format 'yyyy-MM-dd HH:mm:ss'
        projectRoot = $ProjectRoot
        fileCount = $FileCount
        backupVersion = \"1.0\"
        generatedBy = \"HFT Engine Backup Script (PowerShell)\"
    }
    files = $Files
}

# Convert to JSON and save
Write-Host \"Creating backup file...\" -ForegroundColor Green
try {
    $JsonData = $BackupData | ConvertTo-Json -Depth 10 -Compress:$false
    $JsonData | Out-File -FilePath $BackupPath -Encoding UTF8
    
    $BackupSize = (Get-Item $BackupPath).Length
    Write-Host \"Backup created successfully!\" -ForegroundColor Green
    Write-Host \"File: $BackupPath\" -ForegroundColor Yellow
    Write-Host \"Size: $([math]::Round($BackupSize / 1MB, 2)) MB\" -ForegroundColor Yellow
    Write-Host \"Files included: $FileCount\" -ForegroundColor Yellow
}
catch {
    Write-Host \"Error creating backup: $($_.Exception.Message)\" -ForegroundColor Red
    exit 1
}

# Display summary by file type
Write-Host \"`nFile type summary:\" -ForegroundColor Green
$Files | Group-Object -Property type | Sort-Object Name | ForEach-Object {
    Write-Host \"  $($_.Name): $($_.Count) files\" -ForegroundColor Cyan
}

Write-Host \"`nBackup completed successfully!\" -ForegroundColor Green
Write-Host \"Backup saved to: $BackupDir\" -ForegroundColor Yellow"
    },
    {
      "directory": "scripts",
      "fileName": "backup.sh",
      "extension": ".sh",
      "type": "script",
      "relativePath": "scripts/backup.sh",
      "size": 6842,
      "lastModified": "2025-07-10 09:24:04",
      "content": "#!/bin/bash

# HFT Engine Backup Script
# Creates a JSON-formatted backup file (.bkpf) containing all relevant project files
# Saves backups in hft-build-backup folder

PROJECT_NAME=\"hft_engine\"
SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"
PROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"
BACKUP_DIR=\"$PROJECT_ROOT/hft-build-backup\"
BACKUP_FILENAME=\"${PROJECT_NAME}_backup_$(date +%Y%m%d_%H%M%S).bkpf\"
BACKUP_PATH=\"$BACKUP_DIR/$BACKUP_FILENAME\"

echo \"Creating backup for project: $PROJECT_NAME\"
echo \"Project root: $PROJECT_ROOT\"
echo \"Backup directory: $BACKUP_DIR\"
echo \"Backup file: $BACKUP_FILENAME\"

# Create backup directory if it doesn't exist
mkdir -p \"$BACKUP_DIR\"

# Define file extensions and patterns to include
INCLUDE_PATTERNS=(
    \"*.cpp\" \"*.c\" \"*.cc\" \"*.cxx\"     # C++ source files
    \"*.h\" \"*.hpp\" \"*.hxx\"            # Header files
    \"*.py\" \"*.pyx\" \"*.pyi\"           # Python files
    \"*.cmake\" \"*.txt\"                # CMake files
    \"*.md\" \"*.rst\"                   # Documentation
    \"*.json\" \"*.yaml\" \"*.yml\"        # Configuration files
    \"*.sh\" \"*.bat\" \"*.ps1\"           # Scripts
    \"*.gitignore\" \"*.gitattributes\"  # Git files
    \"CMakeLists.txt\"                 # CMake main file
    \"README.md\"                      # README
    \"Dockerfile\"                     # Docker file
    \"Makefile\"                       # Make file
    \"*.toml\" \"*.ini\" \"*.cfg\"         # Config files
)

# Define directories to exclude
EXCLUDE_DIRECTORIES=(
    \"build\" \"Build\" \"BUILD\"
    \"cmake-build-debug\" \"cmake-build-release\"
    \".git\" \".svn\" \".hg\"
    \".idea\" \".vscode\" \".vs\"
    \"external\" \"third_party\" \"deps\"
    \"node_modules\" \"__pycache__\"
    \".pytest_cache\" \".coverage\"
    \"dist\" \"target\" \"out\"
    \"hft-build-backup\"
)

# Function to determine file type based on extension
get_file_type() {
    local ext=\"$1\"
    case \"$ext\" in
        \".cpp\"|\".c\"|\".cc\"|\".cxx\") echo \"source\" ;;
        \".h\"|\".hpp\"|\".hxx\") echo \"header\" ;;
        \".py\"|\".pyx\"|\".pyi\") echo \"python\" ;;
        \".cmake\"|\".txt\") echo \"cmake\" ;;
        \".md\"|\".rst\") echo \"documentation\" ;;
        \".json\"|\".yaml\"|\".yml\"|\".toml\"|\".ini\"|\".cfg\") echo \"configuration\" ;;
        \".sh\"|\".bat\"|\".ps1\") echo \"script\" ;;
        \".gitignore\"|\".gitattributes\") echo \"git\" ;;
        \"\") echo \"special\" ;;  # For files without extension
        *) echo \"other\" ;;
    esac
}

# Function to check if directory should be excluded
should_exclude_directory() {
    local path=\"$1\"
    for exclude_dir in \"${EXCLUDE_DIRECTORIES[@]}\"; do
        if [[ \"$path\" == *\"/$exclude_dir/\"* ]] || [[ \"$path\" == \"$exclude_dir/\"* ]] || [[ \"$path\" == *\"/$exclude_dir\" ]]; then
            return 0
        fi
    done
    return 1
}

# Function to escape JSON strings
escape_json() {
    local str=\"$1\"
    # Replace backslashes first, then quotes, then newlines/tabs/carriage returns
    str=\"${str//\\\\/\\\\\\\\}\"
    str=\"${str//\\\"/\\\\\\\"}\"
    str=\"${str//$'\\n'/\\\\n}\"
    str=\"${str//$'\\r'/\\\\r}\"
    str=\"${str//$'\\t'/\\\\t}\"
    echo \"$str\"
}

echo \"Scanning for files...\"

# Start building the JSON backup file
{
    echo \"{\"
    echo \"  \\\"metadata\\\": {\"
    echo \"    \\\"projectName\\\": \\\"$PROJECT_NAME\\\",\"
    echo \"    \\\"backupDate\\\": \\\"$(date '+%Y-%m-%d %H:%M:%S')\\\",\"
    echo \"    \\\"projectRoot\\\": \\\"$PROJECT_ROOT\\\",\"
    echo \"    \\\"backupVersion\\\": \\\"1.0\\\",\"
    echo \"    \\\"generatedBy\\\": \\\"HFT Engine Backup Script (Bash)\\\",\"
    echo \"    \\\"fileCount\\\": 0\"
    echo \"  },\"
    echo \"  \\\"files\\\": [\"
    
    first_file=true
    file_count=0
    
    # Find all files matching our patterns
    for pattern in \"${INCLUDE_PATTERNS[@]}\"; do
        find \"$PROJECT_ROOT\" -name \"$pattern\" -type f 2>/dev/null | while read -r file; do
            # Skip if file doesn't exist or is not readable
            if [[ ! -r \"$file\" ]]; then
                continue
            fi
            
            relative_path=\"${file#$PROJECT_ROOT/}\"
            
            # Skip if in excluded directory
            if should_exclude_directory \"$relative_path\"; then
                continue
            fi
            
            filename=$(basename \"$file\")
            extension=\"${filename##*.}\"
            if [[ \"$filename\" == \"$extension\" ]]; then
                extension=\"\"
            else
                extension=\".$extension\"
            fi
            
            # Get file metadata
            directory=$(dirname \"$relative_path\")
            if [[ \"$directory\" == \".\" ]]; then
                directory=\"\"
            fi
            
            file_size=$(stat -c%s \"$file\" 2>/dev/null || echo \"0\")
            last_modified=$(stat -c%y \"$file\" 2>/dev/null | cut -d. -f1 || echo \"\")
            file_type=$(get_file_type \"$extension\")
            
            # Read and escape file content
            content=$(cat \"$file\" 2>/dev/null || echo \"\")
            escaped_content=$(escape_json \"$content\")
            
            # Add comma if not first file
            if [[ \"$first_file\" != true ]]; then
                echo \",\"
            fi
            first_file=false
            
            # Add file entry to JSON
            echo \"    {\"
            echo \"      \\\"directory\\\": \\\"$directory\\\",\"
            echo \"      \\\"fileName\\\": \\\"$filename\\\",\"
            echo \"      \\\"extension\\\": \\\"$extension\\\",\"
            echo \"      \\\"type\\\": \\\"$file_type\\\",\"
            echo \"      \\\"relativePath\\\": \\\"$relative_path\\\",\"
            echo \"      \\\"size\\\": $file_size,\"
            echo \"      \\\"lastModified\\\": \\\"$last_modified\\\",\"
            echo \"      \\\"content\\\": \\\"$escaped_content\\\"\"
            echo -n \"    }\"
            
            ((file_count++))
            echo \"  Added: $relative_path\" >&2
        done
    done
    
    echo \"\"
    echo \"  ]\"
    echo \"}\"
} > \"$BACKUP_PATH\"

# Update file count in metadata
temp_file=$(mktemp)
file_count=$(grep -c \"relativePath\" \"$BACKUP_PATH\" 2>/dev/null || echo \"0\")
sed \"s/\\\"fileCount\\\": 0/\\\"fileCount\\\": $file_count/\" \"$BACKUP_PATH\" > \"$temp_file\"
mv \"$temp_file\" \"$BACKUP_PATH\"

echo \"Backup created successfully!\"
echo \"File: $BACKUP_PATH\"
backup_size=$(stat -c%s \"$BACKUP_PATH\" 2>/dev/null || echo \"0\")
backup_size_mb=$(echo \"scale=2; $backup_size / 1024 / 1024\" | bc -l 2>/dev/null || echo \"0\")
echo \"Size: ${backup_size_mb} MB\"
echo \"Files included: $file_count\"

# Display file type summary
echo \"\"
echo \"File type summary:\"
grep -o '\"type\": \"[^\"]*\"' \"$BACKUP_PATH\" | sort | uniq -c | sort -nr | while read count type; do
    type_name=$(echo \"$type\" | cut -d'\"' -f4)
    echo \"  $type_name: $count files\"
done

echo \"\"
echo \"Backup saved to: $BACKUP_DIR\"
ls -lh \"$BACKUP_PATH\""
    },
    {
      "directory": "scripts",
      "fileName": "backup_raw.sh",
      "extension": ".sh",
      "type": "script",
      "relativePath": "scripts/backup_raw.sh",
      "size": 8897,
      "lastModified": "2025-07-10 09:42:05",
      "content": "#!/bin/bash

# HFT Engine Backup Script (Raw Content) - WSL Version
# Creates a JSON-formatted backup file (.bkpf) containing all relevant project files with raw content

# Default parameters
OUTPUT_PATH=\"hft-build-backup\"
PROJECT_NAME=\"hft_engine\"

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -o|--output)
            OUTPUT_PATH=\"$2\"
            shift 2
            ;;
        -n|--name)
            PROJECT_NAME=\"$2\"
            shift 2
            ;;
        -h|--help)
            echo \"Usage: $0 [-o|--output OUTPUT_PATH] [-n|--name PROJECT_NAME]\"
            echo \"  -o, --output    Output directory path (default: hft-build-backup)\"
            echo \"  -n, --name      Project name (default: hft_engine)\"
            exit 0
            ;;
        *)
            echo \"Unknown option: $1\"
            exit 1
            ;;
    esac
done

# Get the project root directory (parent of scripts directory)
SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"
PROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"
BACKUP_DIR=\"$PROJECT_ROOT/$OUTPUT_PATH\"
BACKUP_FILENAME=\"${PROJECT_NAME}_backup_raw_$(date +%Y%m%d_%H%M%S).bkpf\"
BACKUP_PATH=\"$BACKUP_DIR/$BACKUP_FILENAME\"

echo -e \"\\033[32mCreating raw content backup for project: $PROJECT_NAME\\033[0m\"
echo -e \"\\033[33mProject root: $PROJECT_ROOT\\033[0m\"
echo -e \"\\033[33mBackup directory: $BACKUP_DIR\\033[0m\"
echo -e \"\\033[33mBackup file: $BACKUP_FILENAME\\033[0m\"

# Create backup directory if it doesn't exist
if [ ! -d \"$BACKUP_DIR\" ]; then
    mkdir -p \"$BACKUP_DIR\"
    echo -e \"\\033[32mCreated backup directory: $BACKUP_DIR\\033[0m\"
fi

# Define file extensions to include
INCLUDE_EXTENSIONS=(
    \".cpp\" \".c\" \".cc\" \".cxx\"        # C++ source files
    \".h\" \".hpp\" \".hxx\"              # Header files
    \".py\" \".pyx\" \".pyi\"             # Python files
    \".cmake\" \".txt\"                 # CMake files
    \".md\" \".rst\"                    # Documentation
    \".json\" \".yaml\" \".yml\"          # Configuration files
    \".sh\" \".bat\" \".ps1\"             # Scripts
    \".gitignore\" \".gitattributes\"   # Git files
)

# Define special files to always include
SPECIAL_FILES=(
    \"CMakeLists.txt\"
    \"README.md\"
    \"Dockerfile\"
    \"Makefile\"
    \".gitignore\"
)

# Define directories to exclude
EXCLUDE_DIRECTORIES=(
    \"build\" \"Build\" \"BUILD\"
    \"cmake-build-debug\" \"cmake-build-release\"
    \".git\" \".svn\" \".hg\"
    \".idea\" \".vscode\" \".vs\"
    \"external\" \"third_party\" \"deps\"
    \"node_modules\" \"__pycache__\"
    \".pytest_cache\" \".coverage\"
    \"dist\" \"target\" \"out\"
    \"hft-build-backup\"
)

# Function to determine file type based on extension
get_file_type() {
    local extension=\"$1\"
    case \"$extension\" in
        \".cpp\"|\".c\"|\".cc\"|\".cxx\") echo \"source\" ;;
        \".h\"|\".hpp\"|\".hxx\") echo \"header\" ;;
        \".py\"|\".pyx\"|\".pyi\") echo \"python\" ;;
        \".cmake\"|\".txt\") echo \"cmake\" ;;
        \".md\"|\".rst\") echo \"documentation\" ;;
        \".json\"|\".yaml\"|\".yml\") echo \"configuration\" ;;
        \".sh\"|\".bat\"|\".ps1\") echo \"script\" ;;
        \".gitignore\"|\".gitattributes\") echo \"git\" ;;
        \"\") echo \"special\" ;;
        *) echo \"other\" ;;
    esac
}

# Function to check if directory should be excluded
should_exclude_directory() {
    local dir_path=\"$1\"
    for exclude_dir in \"${EXCLUDE_DIRECTORIES[@]}\"; do
        if [[ \"$dir_path\" == *\"$exclude_dir\"* ]]; then
            return 0  # true
        fi
    done
    return 1  # false
}

# Function to check if extension is included
is_extension_included() {
    local extension=\"$1\"
    for inc_ext in \"${INCLUDE_EXTENSIONS[@]}\"; do
        if [[ \"$extension\" == \"$inc_ext\" ]]; then
            return 0  # true
        fi
    done
    return 1  # false
}

# Function to check if file is special
is_special_file() {
    local filename=\"$1\"
    for special_file in \"${SPECIAL_FILES[@]}\"; do
        if [[ \"$filename\" == \"$special_file\" ]]; then
            return 0  # true
        fi
    done
    return 1  # false
}

# Function to escape JSON strings
escape_json() {
    local input=\"$1\"
    # Escape content for JSON without modifying the actual content
    # Only escape what's absolutely necessary for JSON format
    printf '%s' \"$input\" | sed 's/\\\\/\\\\\\\\/g; s/\"/\\\\\"/g'
}

# Function to get file size
get_file_size() {
    local file=\"$1\"
    if [[ \"$OSTYPE\" == \"darwin\"* ]]; then
        stat -f%z \"$file\"
    else
        stat -c%s \"$file\"
    fi
}

# Function to get last modified time
get_last_modified() {
    local file=\"$1\"
    if [[ \"$OSTYPE\" == \"darwin\"* ]]; then
        stat -f \"%Sm\" -t \"%Y-%m-%d %H:%M:%S\" \"$file\"
    else
        stat -c \"%y\" \"$file\" | cut -d'.' -f1
    fi
}

# Collect all relevant files
echo -e \"\\033[32mScanning for files...\\033[0m\"

FILE_COUNT=0
JSON_FILES=\"\"

# Use find to get all files, excluding directories
while IFS= read -r -d '' file; do
    # Get relative path
    relative_path=\"${file#$PROJECT_ROOT/}\"
    
    # Skip if in excluded directory
    if should_exclude_directory \"$relative_path\"; then
        continue
    fi
    
    # Get file extension and name
    filename=$(basename \"$file\")
    extension=\"${filename##*.}\"
    if [[ \"$filename\" == \"$extension\" ]]; then
        extension=\"\"  # No extension
    else
        extension=\".$extension\"
    fi
    
    # Check if file should be included
    if is_extension_included \"$extension\" || is_special_file \"$filename\"; then
        # Try to read file content - preserve exact content without modifications
        if content=$(cat \"$file\" 2>/dev/null); then
            # Get directory path
            directory=$(dirname \"$relative_path\")
            if [[ \"$directory\" == \".\" ]]; then
                directory=\"\"
            fi
            
            # Get file metadata
            file_size=$(get_file_size \"$file\")
            last_modified=$(get_last_modified \"$file\")
            file_type=$(get_file_type \"$extension\")
            
            # Escape content for JSON
            escaped_content=$(escape_json \"$content\")
            
            # Add comma if not first file
            if [[ $FILE_COUNT -gt 0 ]]; then
                JSON_FILES=\"${JSON_FILES},\"
            fi
            
            # Add file to JSON
            JSON_FILES=\"${JSON_FILES}
    {
      \\\"directory\\\": \\\"$(escape_json \"$directory\")\\\",
      \\\"fileName\\\": \\\"$(escape_json \"$filename\")\\\",
      \\\"extension\\\": \\\"$(escape_json \"$extension\")\\\",
      \\\"type\\\": \\\"$(escape_json \"$file_type\")\\\",
      \\\"relativePath\\\": \\\"$(escape_json \"$relative_path\")\\\",
      \\\"size\\\": $file_size,
      \\\"lastModified\\\": \\\"$(escape_json \"$last_modified\")\\\",
      \\\"content\\\": \\\"$escaped_content\\\"
    }\"
            
            ((FILE_COUNT++))
            echo -e \"\\033[32m  Added: $relative_path\\033[0m\"
        else
            echo -e \"\\033[33m  Skipped: $relative_path (binary or inaccessible)\\033[0m\"
        fi
    fi
done < <(find \"$PROJECT_ROOT\" -type f -print0)

# Create backup JSON
echo -e \"\\033[32mCreating raw content backup file...\\033[0m\"

BACKUP_DATE=$(date '+%Y-%m-%d %H:%M:%S')

# Create the complete JSON structure
JSON_CONTENT=\"{
  \\\"metadata\\\": {
    \\\"projectName\\\": \\\"$(escape_json \"$PROJECT_NAME\")\\\",
    \\\"backupDate\\\": \\\"$(escape_json \"$BACKUP_DATE\")\\\",
    \\\"projectRoot\\\": \\\"$(escape_json \"$PROJECT_ROOT\")\\\",
    \\\"fileCount\\\": $FILE_COUNT,
    \\\"backupVersion\\\": \\\"1.0\\\",
    \\\"generatedBy\\\": \\\"HFT Engine Raw Content Backup Script (Bash/WSL)\\\"
  },
  \\\"files\\\": [$JSON_FILES
  ]
}\"

# Write to file
if echo \"$JSON_CONTENT\" > \"$BACKUP_PATH\"; then
    BACKUP_SIZE=$(get_file_size \"$BACKUP_PATH\")
    BACKUP_SIZE_MB=$((BACKUP_SIZE / 1024 / 1024))
    
    echo -e \"\\033[32mRaw content backup created successfully!\\033[0m\"
    echo -e \"\\033[33mFile: $BACKUP_PATH\\033[0m\"
    echo -e \"\\033[33mSize: ${BACKUP_SIZE_MB} MB\\033[0m\"
    echo -e \"\\033[33mFiles included: $FILE_COUNT\\033[0m\"
else
    echo -e \"\\033[31mError creating raw content backup\\033[0m\"
    exit 1
fi

# Display summary by file type
echo -e \"\\n\\033[32mFile type summary:\\033[0m\"
declare -A type_counts
while IFS= read -r -d '' file; do
    relative_path=\"${file#$PROJECT_ROOT/}\"
    if should_exclude_directory \"$relative_path\"; then
        continue
    fi
    
    filename=$(basename \"$file\")
    extension=\"${filename##*.}\"
    if [[ \"$filename\" == \"$extension\" ]]; then
        extension=\"\"
    else
        extension=\".$extension\"
    fi
    
    if is_extension_included \"$extension\" || is_special_file \"$filename\"; then
        if cat \"$file\" >/dev/null 2>&1; then
            file_type=$(get_file_type \"$extension\")
            ((type_counts[\"$file_type\"]++))
        fi
    fi
done < <(find \"$PROJECT_ROOT\" -type f -print0)

for type in \"${!type_counts[@]}\"; do
    echo -e \"\\033[36m  $type: ${type_counts[$type]} files\\033[0m\"
done

echo -e \"\\n\\033[32mRaw content backup completed successfully!\\033[0m\"
echo -e \"\\033[33mBackup saved to: $BACKUP_DIR\\033[0m\""
    },
    {
      "directory": "scripts",
      "fileName": "run_backup.bat",
      "extension": ".bat",
      "type": "script",
      "relativePath": "scripts/run_backup.bat",
      "size": 186,
      "lastModified": "2025-07-10 09:38:55",
      "content": "@echo off
echo Running HFT Engine backup script in WSL...
wsl bash -c \"cd /mnt/c/Users/rajab/CLionProjects/hft_engine && chmod +x scripts/backup_raw.sh && ./scripts/backup_raw.sh %*\""
    },
    {
      "directory": "scripts",
      "fileName": "run_backup.ps1",
      "extension": ".ps1",
      "type": "script",
      "relativePath": "scripts/run_backup.ps1",
      "size": 1130,
      "lastModified": "2025-07-10 09:39:05",
      "content": "# Run HFT Engine backup script in WSL
param(
    [string]$OutputPath = \"hft-build-backup\",
    [string]$ProjectName = \"hft_engine\"
)

Write-Host \"Running HFT Engine backup script in WSL...\" -ForegroundColor Green

# Convert Windows path to WSL path
$WSLPath = \"/mnt/c/Users/rajab/CLionProjects/hft_engine\"

# Build the WSL command
$WSLCommand = \"cd $WSLPath && chmod +x scripts/backup_raw.sh && ./scripts/backup_raw.sh\"

# Add parameters if provided
if ($OutputPath -ne \"hft-build-backup\") {
    $WSLCommand += \" -o '$OutputPath'\"
}
if ($ProjectName -ne \"hft_engine\") {
    $WSLCommand += \" -n '$ProjectName'\"
}

# Run the command in WSL
try {
    wsl bash -c $WSLCommand
    if ($LASTEXITCODE -eq 0) {
        Write-Host \"Backup completed successfully!\" -ForegroundColor Green
    } else {
        Write-Host \"Backup failed with exit code: $LASTEXITCODE\" -ForegroundColor Red
    }
} catch {
    Write-Host \"Error running WSL command: $($_.Exception.Message)\" -ForegroundColor Red
    Write-Host \"Make sure WSL is installed and Ubuntu/Debian distribution is available\" -ForegroundColor Yellow
}"
    },
    {
      "directory": "scripts",
      "fileName": "setup-dev-env.sh",
      "extension": ".sh",
      "type": "script",
      "relativePath": "scripts/setup-dev-env.sh",
      "size": 10213,
      "lastModified": "2025-07-10 08:31:36",
      "content": "#!/bin/bash

# HFT Engine Development Environment Setup
# Sets up the development environment and installs dependencies
# Author: Raja Babu
# Date: 2025-07-10

set -e

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
BLUE='\\033[0;34m'
NC='\\033[0m' # No Color

SCRIPT_DIR=\"$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\"
PROJECT_ROOT=\"$(dirname \"$SCRIPT_DIR\")\"

log_info() {
    echo -e \"${BLUE}[SETUP]${NC} $1\"
}

log_success() {
    echo -e \"${GREEN}[SETUP]${NC} $1\"
}

log_warning() {
    echo -e \"${YELLOW}[SETUP]${NC} $1\"
}

log_error() {
    echo -e \"${RED}[SETUP]${NC} $1\"
}

print_banner() {
    echo \"==================================================================\"
    echo \"               HFT ENGINE DEVELOPMENT SETUP                      \"
    echo \"==================================================================\"
    echo \"Setting up development environment...\"
    echo \"==================================================================\"
}

detect_os() {
    if [[ \"$OSTYPE\" == \"linux-gnu\"* ]]; then
        echo \"linux\"
    elif [[ \"$OSTYPE\" == \"darwin\"* ]]; then
        echo \"macos\"
    elif [[ \"$OSTYPE\" == \"msys\" || \"$OSTYPE\" == \"cygwin\" ]]; then
        echo \"windows\"
    else
        echo \"unknown\"
    fi
}

install_dependencies_ubuntu() {
    log_info \"Installing dependencies for Ubuntu/Debian...\"
    
    sudo apt update
    sudo apt install -y \\
        build-essential \\
        cmake \\
        git \\
        libssl-dev \\
        libboost-all-dev \\
        nlohmann-json3-dev \\
        pkg-config \\
        lcov \\
        gcovr \\
        valgrind \\
        cppcheck \\
        clang-format
    
    log_success \"Ubuntu dependencies installed\"
}

install_dependencies_macos() {
    log_info \"Installing dependencies for macOS...\"
    
    if ! command -v brew &> /dev/null; then
        log_error \"Homebrew not found. Please install Homebrew first:\"
        log_info \"https://brew.sh/\"
        exit 1
    fi
    
    brew install \\
        cmake \\
        boost \\
        openssl \\
        nlohmann-json \\
        lcov \\
        cppcheck \\
        clang-format
    
    log_success \"macOS dependencies installed\"
}

setup_git_hooks() {
    log_info \"Setting up Git hooks...\"
    
    # Create .git/hooks directory if it doesn't exist
    mkdir -p \"$PROJECT_ROOT/.git/hooks\"
    
    # Copy pre-commit hook
    if [ -f \"$SCRIPT_DIR/pre-commit\" ]; then
        cp \"$SCRIPT_DIR/pre-commit\" \"$PROJECT_ROOT/.git/hooks/pre-commit\"
        chmod +x \"$PROJECT_ROOT/.git/hooks/pre-commit\"
        log_success \"Pre-commit hook installed\"
    else
        log_warning \"Pre-commit hook script not found\"
    fi
    
    # Make build script executable
    if [ -f \"$SCRIPT_DIR/hft-build\" ]; then
        chmod +x \"$SCRIPT_DIR/hft-build\"
        log_success \"hft-build script made executable\"
    fi
}

setup_external_dependencies() {
    log_info \"Setting up external dependencies...\"
    
    # Create external directory
    mkdir -p \"$PROJECT_ROOT/external\"
    
    # Clone WebSocket++ if not already present
    if [ ! -d \"$PROJECT_ROOT/external/websocketpp\" ]; then
        log_info \"Cloning WebSocket++ library...\"
        git clone https://github.com/zaphoyd/websocketpp.git \"$PROJECT_ROOT/external/websocketpp\"
        log_success \"WebSocket++ cloned successfully\"
    else
        log_info \"WebSocket++ already exists, updating...\"
        cd \"$PROJECT_ROOT/external/websocketpp\"
        git pull origin develop
        cd \"$PROJECT_ROOT\"
    fi
}

setup_vscode_config() {
    log_info \"Setting up VS Code configuration...\"
    
    mkdir -p \"$PROJECT_ROOT/.vscode\"
    
    # Create settings.json
    cat > \"$PROJECT_ROOT/.vscode/settings.json\" << 'EOF'
{
    \"C_Cpp.default.configurationProvider\": \"ms-vscode.cmake-tools\",
    \"C_Cpp.default.cppStandard\": \"c++17\",
    \"C_Cpp.default.compilerPath\": \"/usr/bin/g++\",
    \"cmake.buildDirectory\": \"${workspaceFolder}/build\",
    \"cmake.generator\": \"Unix Makefiles\",
    \"files.associations\": {
        \"*.h\": \"cpp\",
        \"*.hpp\": \"cpp\",
        \"*.cpp\": \"cpp\"
    },
    \"editor.formatOnSave\": true,
    \"C_Cpp.clang_format_style\": \"Google\"
}
EOF
    
    # Create launch.json for debugging
    cat > \"$PROJECT_ROOT/.vscode/launch.json\" << 'EOF'
{
    \"version\": \"0.2.0\",
    \"configurations\": [
        {
            \"name\": \"Debug HFT Engine\",
            \"type\": \"cppdbg\",
            \"request\": \"launch\",
            \"program\": \"${workspaceFolder}/build/hft_engine\",
            \"args\": [],
            \"stopAtEntry\": false,
            \"cwd\": \"${workspaceFolder}/build\",
            \"environment\": [],
            \"externalConsole\": false,
            \"MIMode\": \"gdb\",
            \"setupCommands\": [
                {
                    \"description\": \"Enable pretty-printing for gdb\",
                    \"text\": \"-enable-pretty-printing\",
                    \"ignoreFailures\": true
                }
            ],
            \"preLaunchTask\": \"Build HFT Engine\"
        },
        {
            \"name\": \"Debug Tests\",
            \"type\": \"cppdbg\",
            \"request\": \"launch\",
            \"program\": \"${workspaceFolder}/build/hft_tests\",
            \"args\": [],
            \"stopAtEntry\": false,
            \"cwd\": \"${workspaceFolder}/build\",
            \"environment\": [],
            \"externalConsole\": false,
            \"MIMode\": \"gdb\",
            \"setupCommands\": [
                {
                    \"description\": \"Enable pretty-printing for gdb\",
                    \"text\": \"-enable-pretty-printing\",
                    \"ignoreFailures\": true
                }
            ],
            \"preLaunchTask\": \"Build HFT Engine\"
        }
    ]
}
EOF
    
    # Create tasks.json
    cat > \"$PROJECT_ROOT/.vscode/tasks.json\" << 'EOF'
{
    \"version\": \"2.0.0\",
    \"tasks\": [
        {
            \"label\": \"Build HFT Engine\",
            \"type\": \"shell\",
            \"command\": \"${workspaceFolder}/scripts/hft-build\",
            \"group\": {
                \"kind\": \"build\",
                \"isDefault\": true
            },
            \"presentation\": {
                \"echo\": true,
                \"reveal\": \"always\",
                \"focus\": false,
                \"panel\": \"shared\"
            },
            \"problemMatcher\": \"$gcc\"
        },
        {
            \"label\": \"Build with Coverage\",
            \"type\": \"shell\",
            \"command\": \"${workspaceFolder}/scripts/hft-build\",
            \"args\": [\"--coverage\"],
            \"group\": \"build\",
            \"presentation\": {
                \"echo\": true,
                \"reveal\": \"always\",
                \"focus\": false,
                \"panel\": \"shared\"
            }
        },
        {
            \"label\": \"Clean Build\",
            \"type\": \"shell\",
            \"command\": \"${workspaceFolder}/scripts/hft-build\",
            \"args\": [\"--clean\"],
            \"group\": \"build\"
        },
        {
            \"label\": \"Run Tests\",
            \"type\": \"shell\",
            \"command\": \"${workspaceFolder}/scripts/hft-build\",
            \"args\": [\"--test-only\"],
            \"group\": \"test\"
        }
    ]
}
EOF
    
    log_success \"VS Code configuration created\"
}

create_sample_config() {
    log_info \"Creating sample configuration files...\"
    
    # Create sample auth config (without real credentials)
    cat > \"$PROJECT_ROOT/auth_config.sample.json\" << 'EOF'
{
    \"api_key\": \"your_binance_api_key_here\",
    \"secret_key\": \"your_binance_secret_key_here\",
    \"passphrase\": \"\"
}
EOF
    
    log_success \"Sample configuration files created\"
    log_warning \"Remember to copy auth_config.sample.json to auth_config.json and add real credentials\"
}

verify_installation() {
    log_info \"Verifying installation...\"
    
    local errors=0
    
    # Check required tools
    local tools=(\"cmake\" \"make\" \"g++\" \"git\")
    for tool in \"${tools[@]}\"; do
        if command -v \"$tool\" &> /dev/null; then
            log_success \"$tool found\"
        else
            log_error \"$tool not found\"
            errors=$((errors + 1))
        fi
    done
    
    # Check libraries
    if pkg-config --exists openssl; then
        log_success \"OpenSSL found\"
    else
        log_error \"OpenSSL not found\"
        errors=$((errors + 1))
    fi
    
    if [ $errors -eq 0 ]; then
        log_success \"All dependencies verified\"
        return 0
    else
        log_error \"$errors dependencies missing\"
        return 1
    fi
}

main() {
    print_banner
    
    local os=$(detect_os)
    log_info \"Detected OS: $os\"
    
    case $os in
        \"linux\")
            install_dependencies_ubuntu
            ;;
        \"macos\")
            install_dependencies_macos
            ;;
        \"windows\")
            log_warning \"Windows detected. Please use WSL or install dependencies manually\"
            ;;
        *)
            log_error \"Unsupported OS: $os\"
            exit 1
            ;;
    esac
    
    setup_external_dependencies
    setup_git_hooks
    setup_vscode_config
    create_sample_config
    
    if verify_installation; then
        log_success \"Development environment setup completed!\"
        echo \"\"
        echo \"==================================================================\"
        echo \"                          NEXT STEPS                             \"
        echo \"==================================================================\"
        echo \"1. Copy auth_config.sample.json to auth_config.json\"
        echo \"2. Add your Binance API credentials to auth_config.json\"
        echo \"3. Run './scripts/hft-build' to build the project\"
        echo \"4. Run './scripts/hft-build --coverage' to run with coverage\"
        echo \"==================================================================\"
    else
        log_error \"Setup completed with errors. Please fix the issues above.\"
        exit 1
    fi
}

main \"$@\""
    },
    {
      "directory": "src",
      "fileName": "auth_manager.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/auth_manager.cpp",
      "size": 5359,
      "lastModified": "2025-07-10 08:14:42",
      "content": "#include \"hft/auth_manager.h\"
#include <openssl/hmac.h>
#include <openssl/sha.h>
#include <fstream>
#include <iostream>
#include <chrono>
#include <iomanip>
#include <sstream>
#include <cstdlib>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

namespace hft {

AuthManager::AuthManager() : credentials_loaded_(false), credentials_(nullptr) {}

AuthManager::~AuthManager() {
    clear_credentials();
}

bool AuthManager::load_credentials() {
    // Try environment variables first
    std::string api_key = read_from_env(\"BINANCE_API_KEY\");
    std::string secret_key = read_from_env(\"BINANCE_SECRET_KEY\");
    
    if (!api_key.empty() && !secret_key.empty()) {
        return set_credentials(api_key, secret_key);
    }
    
    // Fallback to config file
    return load_credentials_from_file(\"auth_config.json\");
}

bool AuthManager::load_credentials_from_file(const std::string& config_path) {
    try {
        std::ifstream file(config_path);
        if (!file.is_open()) {
            std::cerr << \"Warning: Could not open auth config file: \" << config_path << std::endl;
            return false;
        }
        
        json config;
        file >> config;
        
        if (config.contains(\"api_key\") && config.contains(\"secret_key\")) {
            std::string api_key = config[\"api_key\"];
            std::string secret_key = config[\"secret_key\"];
            std::string passphrase = config.value(\"passphrase\", \"\");
            
            credentials_ = std::make_unique<Credentials>();
            credentials_->api_key = api_key;
            credentials_->secret_key = secret_key;
            credentials_->passphrase = passphrase;
            
            credentials_loaded_ = validate_credentials();
            return credentials_loaded_;
        }
    } catch (const std::exception& e) {
        std::cerr << \"Error loading credentials: \" << e.what() << std::endl;
        return false;
    }
    
    return false;
}

bool AuthManager::set_credentials(const std::string& api_key, const std::string& secret_key) {
    if (!is_valid_api_key(api_key) || !is_valid_secret(secret_key)) {
        return false;
    }
    
    credentials_ = std::make_unique<Credentials>();
    credentials_->api_key = api_key;
    credentials_->secret_key = secret_key;
    credentials_->passphrase = \"\";
    
    credentials_loaded_ = true;
    return true;
}

bool AuthManager::validate_credentials() const {
    if (!credentials_) {
        return false;
    }
    
    return is_valid_api_key(credentials_->api_key) && 
           is_valid_secret(credentials_->secret_key);
}

std::optional<AuthManager::Credentials> AuthManager::get_credentials() const {
    if (!credentials_loaded_ || !credentials_) {
        return std::nullopt;
    }
    
    return *credentials_;
}

std::string AuthManager::generate_signature(const std::string& query_string, const std::string& secret) const {
    unsigned char digest[SHA256_DIGEST_LENGTH];
    unsigned int digest_len = SHA256_DIGEST_LENGTH;
    
    HMAC(EVP_sha256(), 
         secret.c_str(), secret.length(),
         reinterpret_cast<const unsigned char*>(query_string.c_str()), query_string.length(),
         digest, &digest_len);
    
    std::stringstream ss;
    for (unsigned int i = 0; i < digest_len; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(digest[i]);
    }
    
    return ss.str();
}

std::string AuthManager::get_timestamp() const {
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    return std::to_string(timestamp);
}

void AuthManager::clear_credentials() {
    if (credentials_) {
        // Clear sensitive data
        credentials_->api_key.clear();
        credentials_->secret_key.clear();
        credentials_->passphrase.clear();
        credentials_.reset();
    }
    credentials_loaded_ = false;
}

bool AuthManager::test_connection() const {
    if (!credentials_loaded_) {
        return false;
    }
    
    // For now, just validate format. In real implementation, 
    // this would make a test API call to verify credentials
    return validate_credentials();
}

bool AuthManager::is_valid_api_key(const std::string& key) const {
    // Binance API keys are typically 64 characters long and alphanumeric
    if (key.length() < 20 || key.length() > 128) {
        return false;
    }
    
    // Check if it contains only valid characters
    for (char c : key) {
        if (!std::isalnum(c)) {
            return false;
        }
    }
    
    return true;
}

bool AuthManager::is_valid_secret(const std::string& secret) const {
    // Similar validation for secret key
    if (secret.length() < 20 || secret.length() > 128) {
        return false;
    }
    
    for (char c : secret) {
        if (!std::isalnum(c) && c != '+' && c != '/' && c != '=') {
            return false;
        }
    }
    
    return true;
}

std::string AuthManager::read_from_env(const std::string& var_name) const {
    const char* value = std::getenv(var_name.c_str());
    return value ? std::string(value) : \"\";
}

} // namespace hft"
    },
    {
      "directory": "src",
      "fileName": "main.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/main.cpp",
      "size": 750,
      "lastModified": "2025-07-09 15:34:03",
      "content": "#include \"hft/matching_engine.h\"
#include \"hft/websocket_client.h\"
#include <nlohmann/json.hpp>
#include <fstream>
#include <iostream>

int main() {
    std::ifstream config_file(\"config.json\");
    if (!config_file.is_open()) {
        std::cerr << \"Error: config.json not found!\" << std::endl;
        return 1;
    }
    auto config = nlohmann::json::parse(config_file);

    hft::MatchingEngine engine(config[\"book_depth\"]);
    engine.run();

    hft::WebsocketClient client(engine, config[\"symbol\"]);

    std::cout << \"Connecting to Binance for symbol: \" << config[\"symbol\"] << std::endl;
    std::cout << \"Press Ctrl+C to exit.\" << std::endl;

    client.run(); // This will block

    engine.stop();
    return 0;
}"
    },
    {
      "directory": "src",
      "fileName": "matching_engine.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/matching_engine.cpp",
      "size": 1127,
      "lastModified": "2025-07-09 15:59:22",
      "content": "    #include \"hft/matching_engine.h\"
#include <chrono>
#include <x86intrin.h>

namespace hft {

    MatchingEngine::MatchingEngine(int book_depth) : book_depth_(book_depth) {}

    MatchingEngine::~MatchingEngine() {
        stop();
    }

    bool MatchingEngine::post_command(Command&& cmd) {
        Command* heap_cmd = new Command(std::move(cmd));
        return command_queue_.push(heap_cmd);
    }

    void MatchingEngine::run() {
        running_ = true;
        writer_thread_ = std::thread(&MatchingEngine::writer_thread_func, this);
    }

    void MatchingEngine::stop() {
        running_ = false;
        if (writer_thread_.joinable()) {
            writer_thread_.join();
        }
    }

    void MatchingEngine::writer_thread_func() {
        while (running_) {
            Command* cmdPtr = nullptr;
            if (command_queue_.pop(cmdPtr)) {
                    order_book_.update(*cmdPtr);
                    order_book_.print_book(book_depth_);
                    delete cmdPtr;
            } else {
                _mm_pause();
            }
        }
    }
}"
    },
    {
      "directory": "src",
      "fileName": "order_book.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/order_book.cpp",
      "size": 1953,
      "lastModified": "2025-07-09 15:34:03",
      "content": "#include \"hft/order_book.h\"
#include <iomanip>

namespace hft {

    void OrderBook::update(const Command& cmd) {
        bids_.clear();
        asks_.clear();
        for (const auto& level : cmd.bids) {
            bids_[level.price] = level.quantity;
        }
        for (const auto& level : cmd.asks) {
            asks_[level.price] = level.quantity;
        }
    }

    void OrderBook::print_book(int depth) const {
        auto bid_it = bids_.cbegin();
        auto ask_it = asks_.cbegin();

        std::cout << \"\\033[2J\\033[1;1H\"; // Clear screen
        std::cout << \"--- ORDER BOOK ---\" << std::endl;
        std::cout << \"------------------------------------\" << std::endl;
        std::cout << \"|       BIDS       |       ASKS       |\" << std::endl;
        std::cout << \"| Price    | Qty     | Price    | Qty     |\" << std::endl;
        std::cout << \"------------------------------------\" << std::endl;

        for (int i = 0; i < depth; ++i) {
            std::cout << \"| \";
            if (bid_it != bids_.end()) {
                std::cout << std::fixed << std::setprecision(2) << std::setw(8) << price_to_double(bid_it->first) << \" | \"
                          << std::setw(7) << bid_it->second << \" |\";
                ++bid_it;
            } else {
                std::cout << std::setw(8) << \" \" << \" | \" << std::setw(7) << \" \" << \" |\";
            }

            if (ask_it != asks_.end()) {
                std::cout << \" \" << std::fixed << std::setprecision(2) << std::setw(8) << price_to_double(ask_it->first) << \" | \"
                          << std::setw(7) << ask_it->second << \" |\";
                ++ask_it;
            } else {
                std::cout << \" \" << std::setw(8) << \" \" << \" | \" << std::setw(7) << \" \" << \" |\";
            }
            std::cout << std::endl;
        }
        std::cout << \"------------------------------------\" << std::endl;
    }
}"
    },
    {
      "directory": "src",
      "fileName": "trading_client.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/trading_client.cpp",
      "size": 10812,
      "lastModified": "2025-07-10 08:15:35",
      "content": "#include \"hft/trading_client.h\"
#include <iostream>
#include <chrono>
#include <random>
#include <thread>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

namespace hft {

TradingClient::TradingClient(std::shared_ptr<AuthManager> auth_manager)
    : auth_manager_(auth_manager), connected_(false), max_order_value_(10000.0) {}

TradingClient::~TradingClient() {
    disconnect();
}

bool TradingClient::connect() {
    if (!auth_manager_ || !auth_manager_->validate_credentials()) {
        handle_error(\"Invalid or missing credentials\");
        return false;
    }
    
    // In a real implementation, this would establish connection to Binance API
    // For now, we'll simulate a connection
    try {
        // Simulate connection delay
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        // Test credentials
        if (!auth_manager_->test_connection()) {
            handle_error(\"Authentication failed\");
            return false;
        }
        
        connected_ = true;
        return true;
    } catch (const std::exception& e) {
        handle_error(\"Connection failed: \" + std::string(e.what()));
        return false;
    }
}

void TradingClient::disconnect() {
    connected_ = false;
    active_orders_.clear();
}

bool TradingClient::is_connected() const {
    return connected_;
}

std::future<OrderId> TradingClient::place_order(const Symbol& symbol, Side side, OrderType type,
                                               Price price, Quantity quantity, TimeInForce tif) {
    return std::async(std::launch::async, [this, symbol, side, type, price, quantity, tif]() -> OrderId {
        if (!connected_) {
            handle_error(\"Not connected to exchange\");
            return \"\";
        }
        
        if (!validate_order(symbol, side, price, quantity)) {
            handle_error(\"Order validation failed\");
            return \"\";
        }
        
        try {
            // Generate unique order ID
            OrderId order_id = generate_order_id();
            
            // Create order object
            Order order;
            order.id = order_id;
            order.symbol = symbol;
            order.side = side;
            order.type = type;
            order.price = price;
            order.quantity = quantity;
            order.time_in_force = tif;
            order.timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            
            // In real implementation, this would send HTTP request to Binance
            // For now, simulate API call delay
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
            
            // Store order in active orders
            active_orders_[order_id] = order;
            
            // Notify callback if set
            if (order_callback_) {
                order_callback_(order);
            }
            
            return order_id;
        } catch (const std::exception& e) {
            handle_error(\"Failed to place order: \" + std::string(e.what()));
            return \"\";
        }
    });
}

std::future<bool> TradingClient::cancel_order(const OrderId& order_id) {
    return std::async(std::launch::async, [this, order_id]() -> bool {
        if (!connected_) {
            handle_error(\"Not connected to exchange\");
            return false;
        }
        
        auto it = active_orders_.find(order_id);
        if (it == active_orders_.end()) {
            handle_error(\"Order not found: \" + order_id);
            return false;
        }
        
        try {
            // Simulate API call delay
            std::this_thread::sleep_for(std::chrono::milliseconds(50));
            
            // Update order status
            it->second.status = OrderStatus::CANCELED;
            
            // Notify callback
            if (order_callback_) {
                order_callback_(it->second);
            }
            
            // Remove from active orders
            active_orders_.erase(it);
            
            return true;
        } catch (const std::exception& e) {
            handle_error(\"Failed to cancel order: \" + std::string(e.what()));
            return false;
        }
    });
}

std::future<bool> TradingClient::cancel_all_orders(const Symbol& symbol) {
    return std::async(std::launch::async, [this, symbol]() -> bool {
        if (!connected_) {
            handle_error(\"Not connected to exchange\");
            return false;
        }
        
        try {
            std::vector<OrderId> orders_to_cancel;
            
            for (const auto& [order_id, order] : active_orders_) {
                if (symbol.empty() || order.symbol == symbol) {
                    orders_to_cancel.push_back(order_id);
                }
            }
            
            // Cancel each order
            for (const auto& order_id : orders_to_cancel) {
                auto future = cancel_order(order_id);
                future.wait(); // Wait for each cancellation
            }
            
            return true;
        } catch (const std::exception& e) {
            handle_error(\"Failed to cancel all orders: \" + std::string(e.what()));
            return false;
        }
    });
}

std::future<std::vector<Order>> TradingClient::get_open_orders(const Symbol& symbol) {
    return std::async(std::launch::async, [this, symbol]() -> std::vector<Order> {
        std::vector<Order> orders;
        
        for (const auto& [order_id, order] : active_orders_) {
            if (symbol.empty() || order.symbol == symbol) {
                orders.push_back(order);
            }
        }
        
        return orders;
    });
}

std::future<std::vector<Trade>> TradingClient::get_trade_history(const Symbol& symbol, int limit) {
    return std::async(std::launch::async, [this, symbol, limit]() -> std::vector<Trade> {
        // Mock trade history
        std::vector<Trade> trades;
        
        // In real implementation, this would fetch from API
        // For now, return empty vector
        return trades;
    });
}

std::future<double> TradingClient::get_account_balance(const std::string& asset) {
    return std::async(std::launch::async, [this, asset]() -> double {
        // Mock balance
        if (asset == \"USDT\") {
            return 10000.0; // Mock USDT balance
        } else if (asset == \"BTC\") {
            return 0.5; // Mock BTC balance
        }
        return 0.0;
    });
}

std::future<Order> TradingClient::get_order_status(const OrderId& order_id) {
    return std::async(std::launch::async, [this, order_id]() -> Order {
        auto it = active_orders_.find(order_id);
        if (it != active_orders_.end()) {
            return it->second;
        }
        
        // Return empty order if not found
        Order empty_order;
        empty_order.status = OrderStatus::REJECTED;
        return empty_order;
    });
}

std::future<double> TradingClient::get_current_price(const Symbol& symbol) {
    return std::async(std::launch::async, [this, symbol]() -> double {
        // Mock current price - in real implementation, fetch from API
        if (symbol == \"BTCUSDT\" || symbol == \"btcusdt\") {
            return 45000.0 + (rand() % 1000 - 500); // Random price around 45000
        }
        return 0.0;
    });
}

std::future<std::pair<Price, Price>> TradingClient::get_bid_ask_spread(const Symbol& symbol) {
    return std::async(std::launch::async, [this, symbol]() -> std::pair<Price, Price> {
        // Mock bid/ask spread
        double mid_price = 45000.0;
        double spread = 0.5;
        return {mid_price - spread, mid_price + spread};
    });
}

void TradingClient::set_order_callback(OrderCallback callback) {
    order_callback_ = callback;
}

void TradingClient::set_trade_callback(TradeCallback callback) {
    trade_callback_ = callback;
}

void TradingClient::set_error_callback(ErrorCallback callback) {
    error_callback_ = callback;
}

void TradingClient::set_max_position_size(const Symbol& symbol, Quantity max_size) {
    max_position_sizes_[symbol] = max_size;
}

void TradingClient::set_max_order_value(double max_value) {
    max_order_value_ = max_value;
}

bool TradingClient::validate_order(const Symbol& symbol, Side side, Price price, Quantity quantity) const {
    if (!validate_price(price) || !validate_quantity(quantity)) {
        return false;
    }
    
    return check_risk_limits(symbol, side, price, quantity);
}

OrderId TradingClient::generate_order_id() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(100000, 999999);
    
    return \"ORDER_\" + std::to_string(dis(gen));
}

std::string TradingClient::get_current_timestamp() {
    auto now = std::chrono::system_clock::now();
    auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(now.time_since_epoch()).count();
    return std::to_string(timestamp);
}

bool TradingClient::check_connection() {
    return connected_;
}

void TradingClient::handle_error(const std::string& error_message) {
    std::cerr << \"TradingClient Error: \" << error_message << std::endl;
    
    if (error_callback_) {
        error_callback_(error_message);
    }
}

bool TradingClient::validate_price(Price price) const {
    return price > 0.0 && price < 1000000.0; // Reasonable price bounds
}

bool TradingClient::validate_quantity(Quantity quantity) const {
    return quantity > 0.0 && quantity < 1000.0; // Reasonable quantity bounds
}

bool TradingClient::check_risk_limits(const Symbol& symbol, Side side, Price price, Quantity quantity) const {
    double order_value = price * quantity;
    
    // Check max order value
    if (order_value > max_order_value_) {
        return false;
    }
    
    // Check position size limits
    auto it = max_position_sizes_.find(symbol);
    if (it != max_position_sizes_.end() && quantity > it->second) {
        return false;
    }
    
    return true;
}

std::string TradingClient::make_authenticated_request(const std::string& endpoint, 
                                                     const std::string& method, 
                                                     const std::string& params) {
    // In real implementation, this would make HTTP requests to Binance API
    // For now, return mock response
    return \"{\\\"status\\\":\\\"success\\\"}\";
}

} // namespace hft"
    },
    {
      "directory": "src",
      "fileName": "ui_manager.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/ui_manager.cpp",
      "size": 13976,
      "lastModified": "2025-07-10 08:16:49",
      "content": "#include \"hft/ui_manager.h\"
#include <iostream>
#include <iomanip>
#include <sstream>
#include <limits>
#include <thread>
#include <chrono>

#ifdef _WIN32
#include <windows.h>
#include <conio.h>
#else
#include <termios.h>
#include <unistd.h>
#endif

namespace hft {

// Color constants
const std::string UIManager::RESET = \"\\033[0m\";
const std::string UIManager::RED = \"\\033[31m\";
const std::string UIManager::GREEN = \"\\033[32m\";
const std::string UIManager::YELLOW = \"\\033[33m\";
const std::string UIManager::BLUE = \"\\033[34m\";
const std::string UIManager::CYAN = \"\\033[36m\";
const std::string UIManager::WHITE = \"\\033[37m\";

UIManager::UIManager() 
    : current_mode_(UIMode::LOGIN), running_(false), initialized_(false), connection_status_(false) {}

UIManager::~UIManager() {
    cleanup();
}

bool UIManager::initialize() {
    if (initialized_) {
        return true;
    }
    
    try {
        // Initialize terminal settings
        clear_screen();
        initialized_ = true;
        return true;
    } catch (const std::exception& e) {
        std::cerr << \"Failed to initialize UI: \" << e.what() << std::endl;
        return false;
    }
}

void UIManager::cleanup() {
    if (initialized_) {
        clear_screen();
        initialized_ = false;
    }
}

void UIManager::run() {
    if (!initialize()) {
        return;
    }
    
    running_ = true;
    
    while (running_) {
        try {
            switch (current_mode_) {
                case UIMode::LOGIN:
                    display_login_screen();
                    break;
                case UIMode::MAIN_MENU:
                    display_main_menu();
                    break;
                case UIMode::ORDER_BOOK_VIEW:
                    // This would display live order book - for now just show menu
                    display_main_menu();
                    break;
                case UIMode::ORDER_MANAGEMENT:
                    // This would show order management interface
                    display_main_menu();
                    break;
                case UIMode::ACCOUNT_INFO:
                    // This would show account information
                    display_main_menu();
                    break;
                case UIMode::SETTINGS:
                    // This would show settings
                    display_main_menu();
                    break;
            }
            
            // Small delay to prevent excessive CPU usage
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        } catch (const std::exception& e) {
            display_error(\"UI Error: \" + std::string(e.what()));
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    }
}

void UIManager::stop() {
    running_ = false;
}

void UIManager::set_mode(UIMode mode) {
    current_mode_ = mode;
    clear_screen();
}

UIMode UIManager::get_current_mode() const {
    return current_mode_;
}

void UIManager::display_login_screen() {
    clear_screen();
    print_header(\"HFT ENGINE - LOGIN\");
    
    std::cout << \"\\n\";
    print_colored(\"Welcome to the High-Frequency Trading Engine\", CYAN);
    std::cout << \"\\n\\n\";
    
    std::cout << \"Please enter your API credentials:\\n\\n\";
    
    auto credentials = get_login_credentials();
    
    // Call login callback if set
    if (login_callback_) {
        bool success = login_callback_(credentials.first, credentials.second);
        if (success) {
            display_status(\"Login successful!\");
            std::this_thread::sleep_for(std::chrono::seconds(1));
            set_mode(UIMode::MAIN_MENU);
        } else {
            display_error(\"Login failed! Please check your credentials.\");
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    } else {
        // No callback set, assume success for demo
        display_status(\"Demo mode - Login bypassed\");
        std::this_thread::sleep_for(std::chrono::seconds(1));
        set_mode(UIMode::MAIN_MENU);
    }
}

void UIManager::display_main_menu() {
    clear_screen();
    print_header(\"HFT ENGINE - MAIN MENU\");
    
    // Show connection status
    if (connection_status_) {
        print_colored(\"Status: CONNECTED\", GREEN);
    } else {
        print_colored(\"Status: DISCONNECTED\", RED);
    }
    std::cout << \"\\n\\n\";
    
    std::vector<std::string> options = {
        \"1. View Order Book\",
        \"2. Order Management\",
        \"3. Account Information\",
        \"4. Settings\",
        \"5. Exit\"
    };
    
    draw_menu(options);
    
    int choice = get_menu_choice(options);
    
    switch (choice) {
        case 1:
            set_mode(UIMode::ORDER_BOOK_VIEW);
            break;
        case 2:
            set_mode(UIMode::ORDER_MANAGEMENT);
            break;
        case 3:
            set_mode(UIMode::ACCOUNT_INFO);
            break;
        case 4:
            set_mode(UIMode::SETTINGS);
            break;
        case 5:
            stop();
            break;
        default:
            display_error(\"Invalid choice\");
            std::this_thread::sleep_for(std::chrono::seconds(1));
            break;
    }
}

void UIManager::display_order_book(const OrderBook& order_book, int depth) {
    clear_screen();
    print_header(\"REAL-TIME ORDER BOOK\");
    
    // This would integrate with the existing order book display
    // For now, show placeholder
    std::cout << \"Order book display would appear here...\\n\";
    std::cout << \"Press any key to return to main menu...\\n\";
    wait_for_key();
    set_mode(UIMode::MAIN_MENU);
}

void UIManager::display_order_management(const std::vector<Order>& orders) {
    clear_screen();
    print_header(\"ORDER MANAGEMENT\");
    
    if (orders.empty()) {
        std::cout << \"No active orders.\\n\\n\";
    } else {
        draw_order_table(orders);
    }
    
    std::vector<std::string> options = {
        \"1. Place New Order\",
        \"2. Cancel Order\",
        \"3. Cancel All Orders\",
        \"4. Refresh\",
        \"5. Back to Main Menu\"
    };
    
    draw_menu(options);
    
    int choice = get_menu_choice(options);
    
    switch (choice) {
        case 1: {
            Order new_order = get_order_input(\"BTCUSDT\");
            if (order_callback_) {
                order_callback_(new_order.symbol, new_order.side, new_order.type, 
                               new_order.price, new_order.quantity);
            }
            break;
        }
        case 2: {
            std::string order_id = get_cancel_order_id();
            if (!order_id.empty() && cancel_callback_) {
                cancel_callback_(order_id);
            }
            break;
        }
        case 3:
            // Cancel all orders logic
            display_status(\"Cancelling all orders...\");
            break;
        case 4:
            // Refresh logic
            break;
        case 5:
            set_mode(UIMode::MAIN_MENU);
            break;
    }
}

void UIManager::display_account_info(double balance, const std::vector<Trade>& recent_trades) {
    clear_screen();
    print_header(\"ACCOUNT INFORMATION\");
    
    std::cout << std::fixed << std::setprecision(2);
    std::cout << \"Account Balance: $\" << balance << \" USDT\\n\\n\";
    
    if (!recent_trades.empty()) {
        std::cout << \"Recent Trades:\\n\";
        std::cout << std::left << std::setw(15) << \"Order ID\" 
                  << std::setw(10) << \"Side\" 
                  << std::setw(12) << \"Price\" 
                  << std::setw(12) << \"Quantity\" << \"\\n\";
        print_separator();
        
        for (const auto& trade : recent_trades) {
            std::cout << std::left << std::setw(15) << trade.order_id
                      << std::setw(10) << (trade.side == Side::BUY ? \"BUY\" : \"SELL\")
                      << std::setw(12) << trade.price
                      << std::setw(12) << trade.quantity << \"\\n\";
        }
    }
    
    std::cout << \"\\nPress any key to return to main menu...\";
    wait_for_key();
    set_mode(UIMode::MAIN_MENU);
}

void UIManager::display_error(const std::string& message) {
    print_colored(\"ERROR: \" + message, RED);
    std::cout << \"\\n\";
}

void UIManager::display_status(const std::string& message) {
    print_colored(\"STATUS: \" + message, GREEN);
    std::cout << \"\\n\";
}

std::pair<std::string, std::string> UIManager::get_login_credentials() {
    std::string api_key, secret_key;
    
    std::cout << \"API Key: \";
    std::getline(std::cin, api_key);
    
    std::cout << \"Secret Key: \";
    std::getline(std::cin, secret_key);
    
    return {api_key, secret_key};
}

int UIManager::get_menu_choice(const std::vector<std::string>& options) {
    std::cout << \"\\nEnter your choice: \";
    int choice;
    std::cin >> choice;
    
    // Clear input buffer
    std::cin.clear();
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');
    
    return choice;
}

Order UIManager::get_order_input(const Symbol& symbol) {
    clear_screen();
    print_header(\"PLACE NEW ORDER\");
    
    Order order;
    order.symbol = symbol;
    
    std::cout << \"Symbol: \" << symbol << \"\\n\\n\";
    
    // Get side
    std::cout << \"Side (1=BUY, 2=SELL): \";
    int side_choice;
    std::cin >> side_choice;
    order.side = (side_choice == 1) ? Side::BUY : Side::SELL;
    
    // Get order type
    std::cout << \"Order Type (1=MARKET, 2=LIMIT): \";
    int type_choice;
    std::cin >> type_choice;
    order.type = (type_choice == 1) ? OrderType::MARKET : OrderType::LIMIT;
    
    // Get price (if limit order)
    if (order.type == OrderType::LIMIT) {
        order.price = get_numeric_input(\"Price: \");
    }
    
    // Get quantity
    order.quantity = get_numeric_input(\"Quantity: \");
    
    // Clear input buffer
    std::cin.clear();
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');
    
    return order;
}

std::string UIManager::get_cancel_order_id() {
    std::string order_id = get_input(\"Enter Order ID to cancel: \");
    return order_id;
}

void UIManager::set_login_callback(LoginCallback callback) {
    login_callback_ = callback;
}

void UIManager::set_order_callback(OrderCallback callback) {
    order_callback_ = callback;
}

void UIManager::set_cancel_callback(CancelCallback callback) {
    cancel_callback_ = callback;
}

void UIManager::update_connection_status(bool connected) {
    connection_status_ = connected;
}

void UIManager::update_order_book(const OrderBook& order_book) {
    // Implementation would update order book display
}

void UIManager::update_orders(const std::vector<Order>& orders) {
    // Implementation would update order display
}

void UIManager::update_balance(double balance) {
    // Implementation would update balance display
}

void UIManager::clear_screen() {
#ifdef _WIN32
    system(\"cls\");
#else
    system(\"clear\");
#endif
}

void UIManager::print_header(const std::string& title) {
    print_separator();
    std::cout << \"‚îÇ \" << std::left << std::setw(76) << title << \" ‚îÇ\\n\";
    print_separator();
}

void UIManager::print_separator() {
    std::cout << \"‚îå\" << std::string(78, '‚îÄ') << \"‚îê\\n\";
}

void UIManager::wait_for_key() {
#ifdef _WIN32
    _getch();
#else
    getchar();
#endif
}

std::string UIManager::get_input(const std::string& prompt) {
    std::cout << prompt;
    std::string input;
    std::getline(std::cin, input);
    return input;
}

double UIManager::get_numeric_input(const std::string& prompt) {
    std::cout << prompt;
    double value;
    std::cin >> value;
    return value;
}

char UIManager::get_char_input() {
#ifdef _WIN32
    return _getch();
#else
    return getchar();
#endif
}

void UIManager::print_colored(const std::string& text, const std::string& color) {
    std::cout << color << text << RESET;
}

void UIManager::draw_border() {
    std::cout << \"+\" << std::string(78, '-') << \"+\\n\";
}

void UIManager::draw_order_book_table(const OrderBook& order_book, int depth) {
    // Implementation would draw order book table
}

void UIManager::draw_order_table(const std::vector<Order>& orders) {
    std::cout << std::left << std::setw(15) << \"Order ID\" 
              << std::setw(10) << \"Symbol\" 
              << std::setw(8) << \"Side\" 
              << std::setw(10) << \"Type\"
              << std::setw(12) << \"Price\" 
              << std::setw(12) << \"Quantity\" 
              << std::setw(10) << \"Status\" << \"\\n\";
    print_separator();
    
    for (const auto& order : orders) {
        std::cout << std::left << std::setw(15) << order.id
                  << std::setw(10) << order.symbol
                  << std::setw(8) << (order.side == Side::BUY ? \"BUY\" : \"SELL\")
                  << std::setw(10) << (order.type == OrderType::MARKET ? \"MARKET\" : \"LIMIT\")
                  << std::setw(12) << std::fixed << std::setprecision(2) << order.price
                  << std::setw(12) << order.quantity
                  << std::setw(10) << \"NEW\" << \"\\n\";
    }
}

void UIManager::draw_menu(const std::vector<std::string>& options) {
    for (const auto& option : options) {
        std::cout << option << \"\\n\";
    }
}

bool UIManager::validate_price_input(const std::string& input) {
    try {
        double price = std::stod(input);
        return price > 0.0;
    } catch (...) {
        return false;
    }
}

bool UIManager::validate_quantity_input(const std::string& input) {
    try {
        double quantity = std::stod(input);
        return quantity > 0.0;
    } catch (...) {
        return false;
    }
}

} // namespace hft"
    },
    {
      "directory": "src",
      "fileName": "websocket_client.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "src/websocket_client.cpp",
      "size": 2082,
      "lastModified": "2025-07-09 15:34:03",
      "content": "#include \"hft/websocket_client.h\"
#include <nlohmann/json.hpp>

namespace hft {

    WebsocketClient::WebsocketClient(MatchingEngine& engine, std::string symbol)
        : engine_(engine), symbol_(symbol) {

        uri_ = \"wss://stream.binance.com:9443/ws/\" + symbol_ + \"@depth20@100ms\";

        ws_client_.init_asio();
        ws_client_.set_tls_init_handler([](websocketpp::connection_hdl){
            return std::make_shared<boost::asio::ssl::context>(boost::asio::ssl::context::sslv23);
        });

        ws_client_.set_message_handler(
            std::bind(&WebsocketClient::on_message, this,
                      std::placeholders::_1, std::placeholders::_2)
        );
    }

    void WebsocketClient::run() {
        websocketpp::lib::error_code ec;
        client::connection_ptr con = ws_client_.get_connection(uri_, ec);
        if (ec) {
            std::cout << \"Could not create connection: \" << ec.message() << std::endl;
            return;
        }
        ws_client_.connect(con);
        ws_client_.run();
    }

    void WebsocketClient::on_message(websocketpp::connection_hdl hdl, client::message_ptr msg) {
        auto json = nlohmann::json::parse(msg->get_payload());

        Command cmd;
        cmd.type = CommandType::MARKET_DATA;
        cmd.timestamp_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(
            std::chrono::system_clock::now().time_since_epoch()
        ).count();

        for (const auto& bid : json[\"bids\"]) {
            cmd.bids.push_back({
                price_to_int(std::stod(bid[0].get<std::string>())),
                (Quantity)std::stod(bid[1].get<std::string>())
            });
        }

        for (const auto& ask : json[\"asks\"]) {
            cmd.asks.push_back({
                price_to_int(std::stod(ask[0].get<std::string>())),
                (Quantity)std::stod(ask[1].get<std::string>())
            });
        }

        while (!engine_.post_command(std::move(cmd))) {
            // Spin if the queue is full
        }
    }
}"
    },
    {
      "directory": "tests",
      "fileName": "CMakeLists.txt",
      "extension": ".txt",
      "type": "cmake",
      "relativePath": "tests/CMakeLists.txt",
      "size": 320,
      "lastModified": "2025-07-10 08:27:39",
      "content": "find_package(GTest REQUIRED)
include(GoogleTest)

add_executable(hft_tests
    test_order_book.cpp
    test_auth_manager.cpp
    test_trading_client.cpp
)

target_link_libraries(hft_tests
        PRIVATE
        GTest::gtest
        GTest::gtest_main
        hft_core
)

gtest_discover_tests(hft_tests)"
    },
    {
      "directory": "tests",
      "fileName": "test_auth_manager.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "tests/test_auth_manager.cpp",
      "size": 7601,
      "lastModified": "2025-07-10 08:32:47",
      "content": "#include <gtest/gtest.h>
#include \"hft/auth_manager.h\"
#include <fstream>
#include <cstdlib>
#include <thread>
#include <chrono>

class AuthManagerTest : public ::testing::Test {
protected:
    void SetUp() override {
        auth_manager = std::make_unique<hft::AuthManager>();
        
        // Clean environment variables
#ifdef _WIN32
        _putenv(\"BINANCE_API_KEY=\");
        _putenv(\"BINANCE_SECRET_KEY=\");
#else
        unsetenv(\"BINANCE_API_KEY\");
        unsetenv(\"BINANCE_SECRET_KEY\");
#endif
        
        // Create test config file
        test_config_file = \"test_auth_config.json\";
        std::ofstream file(test_config_file);
        file << R\"({
            \"api_key\": \"testApiKey12345678901234567890123456789012345678901234567890\",
            \"secret_key\": \"testSecretKey123456789012345678901234567890123456789012345\"
        })\";
        file.close();
        
        invalid_config_file = \"invalid_auth_config.json\";
        std::ofstream invalid_file(invalid_config_file);
        invalid_file << R\"({
            \"api_key\": \"short\",
            \"secret_key\": \"alsoshort\"
        })\";
        invalid_file.close();
    }

    void TearDown() override {
        // Clean up test files
        std::remove(test_config_file.c_str());
        std::remove(invalid_config_file.c_str());
    }

    std::unique_ptr<hft::AuthManager> auth_manager;
    std::string test_config_file;
    std::string invalid_config_file;
};

TEST_F(AuthManagerTest, InitialState) {
    EXPECT_FALSE(auth_manager->validate_credentials());
    EXPECT_FALSE(auth_manager->get_credentials().has_value());
    EXPECT_FALSE(auth_manager->test_connection());
}

TEST_F(AuthManagerTest, SetValidCredentials) {
    std::string valid_api_key = \"testApiKey12345678901234567890123456789012345678901234567890\";
    std::string valid_secret = \"testSecretKey123456789012345678901234567890123456789012345\";
    
    EXPECT_TRUE(auth_manager->set_credentials(valid_api_key, valid_secret));
    EXPECT_TRUE(auth_manager->validate_credentials());
    
    auto credentials = auth_manager->get_credentials();
    ASSERT_TRUE(credentials.has_value());
    EXPECT_EQ(credentials->api_key, valid_api_key);
    EXPECT_EQ(credentials->secret_key, valid_secret);
}

TEST_F(AuthManagerTest, SetInvalidCredentials) {
    // Test short API key
    EXPECT_FALSE(auth_manager->set_credentials(\"short\", \"validSecretKey123456789012345678901234567890123456789012345\"));
    
    // Test short secret key
    EXPECT_FALSE(auth_manager->set_credentials(\"validApiKey12345678901234567890123456789012345678901234567890\", \"short\"));
    
    // Test invalid characters
    EXPECT_FALSE(auth_manager->set_credentials(\"invalid@key#\", \"validSecretKey123456789012345678901234567890123456789012345\"));
}

TEST_F(AuthManagerTest, LoadFromValidConfigFile) {
    EXPECT_TRUE(auth_manager->load_credentials_from_file(test_config_file));
    EXPECT_TRUE(auth_manager->validate_credentials());
    
    auto credentials = auth_manager->get_credentials();
    ASSERT_TRUE(credentials.has_value());
    EXPECT_EQ(credentials->api_key, \"testApiKey12345678901234567890123456789012345678901234567890\");
    EXPECT_EQ(credentials->secret_key, \"testSecretKey123456789012345678901234567890123456789012345\");
}

TEST_F(AuthManagerTest, LoadFromInvalidConfigFile) {
    EXPECT_FALSE(auth_manager->load_credentials_from_file(invalid_config_file));
    EXPECT_FALSE(auth_manager->validate_credentials());
}

TEST_F(AuthManagerTest, LoadFromNonexistentFile) {
    EXPECT_FALSE(auth_manager->load_credentials_from_file(\"nonexistent.json\"));
    EXPECT_FALSE(auth_manager->validate_credentials());
}

TEST_F(AuthManagerTest, GenerateSignature) {
    std::string query_string = \"symbol=BTCUSDT&side=BUY&type=LIMIT&timeInForce=GTC&quantity=1&price=9000&recvWindow=5000&timestamp=1499827319559\";
    std::string secret = \"NhqPtmdSJYdKjVHjA7PZj4Mge3R5YNiP1e3UZjInClVN65XAbvqqM6A7H5fATj0j\";
    
    std::string signature = auth_manager->generate_signature(query_string, secret);
    EXPECT_FALSE(signature.empty());
    EXPECT_EQ(signature.length(), 64); // SHA256 hex string length
    
    // Test consistency
    std::string signature2 = auth_manager->generate_signature(query_string, secret);
    EXPECT_EQ(signature, signature2);
}

TEST_F(AuthManagerTest, GetTimestamp) {
    std::string timestamp1 = auth_manager->get_timestamp();
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::string timestamp2 = auth_manager->get_timestamp();
    
    EXPECT_FALSE(timestamp1.empty());
    EXPECT_FALSE(timestamp2.empty());
    EXPECT_NE(timestamp1, timestamp2);
    
    // Verify timestamp is numeric
    EXPECT_NO_THROW(std::stoull(timestamp1));
    EXPECT_NO_THROW(std::stoull(timestamp2));
}

TEST_F(AuthManagerTest, ClearCredentials) {
    // Set credentials first
    auth_manager->set_credentials(
        \"testApiKey12345678901234567890123456789012345678901234567890\",
        \"testSecretKey123456789012345678901234567890123456789012345\"
    );
    EXPECT_TRUE(auth_manager->validate_credentials());
    
    // Clear credentials
    auth_manager->clear_credentials();
    EXPECT_FALSE(auth_manager->validate_credentials());
    EXPECT_FALSE(auth_manager->get_credentials().has_value());
}

TEST_F(AuthManagerTest, TestConnection) {
    // Without credentials
    EXPECT_FALSE(auth_manager->test_connection());
    
    // With valid credentials
    auth_manager->set_credentials(
        \"testApiKey12345678901234567890123456789012345678901234567890\",
        \"testSecretKey123456789012345678901234567890123456789012345\"
    );
    EXPECT_TRUE(auth_manager->test_connection());
}

TEST_F(AuthManagerTest, LoadFromEnvironmentVariables) {
    // Set environment variables
#ifdef _WIN32
    _putenv(\"BINANCE_API_KEY=envApiKey12345678901234567890123456789012345678901234567890\");
    _putenv(\"BINANCE_SECRET_KEY=envSecretKey123456789012345678901234567890123456789012345\");
#else
    setenv(\"BINANCE_API_KEY\", \"envApiKey12345678901234567890123456789012345678901234567890\", 1);
    setenv(\"BINANCE_SECRET_KEY\", \"envSecretKey123456789012345678901234567890123456789012345\", 1);
#endif
    
    EXPECT_TRUE(auth_manager->load_credentials());
    EXPECT_TRUE(auth_manager->validate_credentials());
    
    auto credentials = auth_manager->get_credentials();
    ASSERT_TRUE(credentials.has_value());
    EXPECT_EQ(credentials->api_key, \"envApiKey12345678901234567890123456789012345678901234567890\");
    EXPECT_EQ(credentials->secret_key, \"envSecretKey123456789012345678901234567890123456789012345\");
    
    // Clean up
    unsetenv(\"BINANCE_API_KEY\");
    unsetenv(\"BINANCE_SECRET_KEY\");
}

TEST_F(AuthManagerTest, LoadCredentialsFallback) {
    // No environment variables, should fallback to config file
    EXPECT_TRUE(auth_manager->load_credentials_from_file(test_config_file));
    
    // Create auth_config.json for the load_credentials() method
    std::ofstream file(\"auth_config.json\");
    file << R\"({
        \"api_key\": \"configApiKey12345678901234567890123456789012345678901234567890\",
        \"secret_key\": \"configSecretKey123456789012345678901234567890123456789012345\"
    })\";
    file.close();
    
    // Clear current credentials
    auth_manager->clear_credentials();
    
    // Load should fallback to config file
    EXPECT_TRUE(auth_manager->load_credentials());
    
    // Clean up
    std::remove(\"auth_config.json\");
}"
    },
    {
      "directory": "tests",
      "fileName": "test_order_book.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "tests/test_order_book.cpp",
      "size": 467,
      "lastModified": "2025-07-09 15:34:03",
      "content": "#include <gtest/gtest.h>
#include \"hft/order_book.h\"

TEST(OrderBookTest, UpdateAndPrint) {
    hft::OrderBook book;
    hft::Command cmd;
    cmd.type = hft::CommandType::MARKET_DATA;
    cmd.bids.push_back({hft::price_to_int(100.50), 10});
    cmd.asks.push_back({hft::price_to_int(100.55), 5});

    book.update(cmd);

    // In a real test, you'd capture stdout or check internal state.
    // Here we just ensure it doesn't crash.
    SUCCEED();
}"
    },
    {
      "directory": "tests",
      "fileName": "test_trading_client.cpp",
      "extension": ".cpp",
      "type": "source",
      "relativePath": "tests/test_trading_client.cpp",
      "size": 10866,
      "lastModified": "2025-07-10 08:19:15",
      "content": "#include <gtest/gtest.h>
#include \"hft/trading_client.h\"
#include \"hft/auth_manager.h\"
#include <memory>
#include <chrono>
#include <thread>

class TradingClientTest : public ::testing::Test {
protected:
    void SetUp() override {
        auth_manager = std::make_shared<hft::AuthManager>();
        auth_manager->set_credentials(
            \"testApiKey12345678901234567890123456789012345678901234567890\",
            \"testSecretKey123456789012345678901234567890123456789012345\"
        );
        
        trading_client = std::make_unique<hft::TradingClient>(auth_manager);
        
        // Set up callbacks for testing
        order_callback_called = false;
        trade_callback_called = false;
        error_callback_called = false;
        last_error_message = \"\";
        
        trading_client->set_order_callback([this](const hft::Order& order) {
            order_callback_called = true;
            last_order = order;
        });
        
        trading_client->set_trade_callback([this](const hft::Trade& trade) {
            trade_callback_called = true;
            last_trade = trade;
        });
        
        trading_client->set_error_callback([this](const std::string& error) {
            error_callback_called = true;
            last_error_message = error;
        });
    }

    void TearDown() override {
        if (trading_client && trading_client->is_connected()) {
            trading_client->disconnect();
        }
    }

    std::shared_ptr<hft::AuthManager> auth_manager;
    std::unique_ptr<hft::TradingClient> trading_client;
    
    // Callback tracking
    bool order_callback_called;
    bool trade_callback_called;
    bool error_callback_called;
    std::string last_error_message;
    hft::Order last_order;
    hft::Trade last_trade;
};

TEST_F(TradingClientTest, InitialState) {
    EXPECT_FALSE(trading_client->is_connected());
}

TEST_F(TradingClientTest, ConnectWithValidCredentials) {
    EXPECT_TRUE(trading_client->connect());
    EXPECT_TRUE(trading_client->is_connected());
}

TEST_F(TradingClientTest, ConnectWithoutCredentials) {
    auto no_auth_manager = std::make_shared<hft::AuthManager>();
    auto no_auth_client = std::make_unique<hft::TradingClient>(no_auth_manager);
    
    EXPECT_FALSE(no_auth_client->connect());
    EXPECT_FALSE(no_auth_client->is_connected());
}

TEST_F(TradingClientTest, DisconnectAndReconnect) {
    EXPECT_TRUE(trading_client->connect());
    EXPECT_TRUE(trading_client->is_connected());
    
    trading_client->disconnect();
    EXPECT_FALSE(trading_client->is_connected());
    
    EXPECT_TRUE(trading_client->connect());
    EXPECT_TRUE(trading_client->is_connected());
}

TEST_F(TradingClientTest, PlaceValidOrder) {
    EXPECT_TRUE(trading_client->connect());
    
    auto future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    
    // Wait for the async operation to complete
    auto order_id = future.get();
    
    EXPECT_FALSE(order_id.empty());
    EXPECT_TRUE(order_callback_called);
    EXPECT_EQ(last_order.symbol, \"BTCUSDT\");
    EXPECT_EQ(last_order.side, hft::Side::BUY);
    EXPECT_EQ(last_order.type, hft::OrderType::LIMIT);
    EXPECT_EQ(last_order.price, 45000.0);
    EXPECT_EQ(last_order.quantity, 0.001);
}

TEST_F(TradingClientTest, PlaceOrderWithoutConnection) {
    auto future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    
    auto order_id = future.get();
    
    EXPECT_TRUE(order_id.empty());
    EXPECT_TRUE(error_callback_called);
    EXPECT_FALSE(order_callback_called);
}

TEST_F(TradingClientTest, PlaceInvalidOrder) {
    EXPECT_TRUE(trading_client->connect());
    
    // Invalid price (negative)
    auto future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, -45000.0, 0.001);
    
    auto order_id = future.get();
    
    EXPECT_TRUE(order_id.empty());
    EXPECT_TRUE(error_callback_called);
    EXPECT_FALSE(order_callback_called);
}

TEST_F(TradingClientTest, CancelValidOrder) {
    EXPECT_TRUE(trading_client->connect());
    
    // Place an order first
    auto place_future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    auto order_id = place_future.get();
    EXPECT_FALSE(order_id.empty());
    
    // Reset callback flag
    order_callback_called = false;
    
    // Cancel the order
    auto cancel_future = trading_client->cancel_order(order_id);
    bool success = cancel_future.get();
    
    EXPECT_TRUE(success);
    EXPECT_TRUE(order_callback_called);
    EXPECT_EQ(last_order.status, hft::OrderStatus::CANCELED);
}

TEST_F(TradingClientTest, CancelNonexistentOrder) {
    EXPECT_TRUE(trading_client->connect());
    
    auto future = trading_client->cancel_order(\"NONEXISTENT_ORDER\");
    bool success = future.get();
    
    EXPECT_FALSE(success);
    EXPECT_TRUE(error_callback_called);
}

TEST_F(TradingClientTest, CancelOrderWithoutConnection) {
    auto future = trading_client->cancel_order(\"ORDER_123456\");
    bool success = future.get();
    
    EXPECT_FALSE(success);
    EXPECT_TRUE(error_callback_called);
}

TEST_F(TradingClientTest, GetOpenOrders) {
    EXPECT_TRUE(trading_client->connect());
    
    // Place some orders
    auto future1 = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    auto future2 = trading_client->place_order(\"BTCUSDT\", hft::Side::SELL, hft::OrderType::LIMIT, 46000.0, 0.001);
    
    future1.get();
    future2.get();
    
    // Get open orders
    auto orders_future = trading_client->get_open_orders(\"BTCUSDT\");
    auto orders = orders_future.get();
    
    EXPECT_EQ(orders.size(), 2);
}

TEST_F(TradingClientTest, GetOpenOrdersEmptySymbol) {
    EXPECT_TRUE(trading_client->connect());
    
    auto orders_future = trading_client->get_open_orders(\"\");
    auto orders = orders_future.get();
    
    EXPECT_TRUE(orders.empty());
}

TEST_F(TradingClientTest, GetAccountBalance) {
    EXPECT_TRUE(trading_client->connect());
    
    auto balance_future = trading_client->get_account_balance(\"USDT\");
    double balance = balance_future.get();
    
    EXPECT_GT(balance, 0.0);
}

TEST_F(TradingClientTest, GetCurrentPrice) {
    EXPECT_TRUE(trading_client->connect());
    
    auto price_future = trading_client->get_current_price(\"BTCUSDT\");
    double price = price_future.get();
    
    EXPECT_GT(price, 0.0);
}

TEST_F(TradingClientTest, GetBidAskSpread) {
    EXPECT_TRUE(trading_client->connect());
    
    auto spread_future = trading_client->get_bid_ask_spread(\"BTCUSDT\");
    auto spread = spread_future.get();
    
    EXPECT_GT(spread.first, 0.0);  // bid
    EXPECT_GT(spread.second, 0.0); // ask
    EXPECT_LT(spread.first, spread.second); // bid < ask
}

TEST_F(TradingClientTest, RiskManagementMaxOrderValue) {
    EXPECT_TRUE(trading_client->connect());
    
    trading_client->set_max_order_value(1000.0);
    
    // Try to place order with value > max_order_value
    auto future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 1.0); // 45000 > 1000
    
    auto order_id = future.get();
    
    EXPECT_TRUE(order_id.empty());
    EXPECT_TRUE(error_callback_called);
}

TEST_F(TradingClientTest, RiskManagementMaxPositionSize) {
    EXPECT_TRUE(trading_client->connect());
    
    trading_client->set_max_position_size(\"BTCUSDT\", 0.01);
    
    // Try to place order with quantity > max_position_size
    auto future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.1);
    
    auto order_id = future.get();
    
    EXPECT_TRUE(order_id.empty());
    EXPECT_TRUE(error_callback_called);
}

TEST_F(TradingClientTest, OrderValidation) {
    EXPECT_TRUE(trading_client->connect());
    
    // Valid order
    EXPECT_TRUE(trading_client->validate_order(\"BTCUSDT\", hft::Side::BUY, 45000.0, 0.001));
    
    // Invalid price
    EXPECT_FALSE(trading_client->validate_order(\"BTCUSDT\", hft::Side::BUY, -45000.0, 0.001));
    EXPECT_FALSE(trading_client->validate_order(\"BTCUSDT\", hft::Side::BUY, 0.0, 0.001));
    
    // Invalid quantity
    EXPECT_FALSE(trading_client->validate_order(\"BTCUSDT\", hft::Side::BUY, 45000.0, 0.0));
    EXPECT_FALSE(trading_client->validate_order(\"BTCUSDT\", hft::Side::BUY, 45000.0, -0.001));
}

TEST_F(TradingClientTest, CancelAllOrders) {
    EXPECT_TRUE(trading_client->connect());
    
    // Place multiple orders
    auto future1 = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    auto future2 = trading_client->place_order(\"BTCUSDT\", hft::Side::SELL, hft::OrderType::LIMIT, 46000.0, 0.001);
    auto future3 = trading_client->place_order(\"ETHUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 3000.0, 0.01);
    
    future1.get();
    future2.get();
    future3.get();
    
    // Cancel all BTCUSDT orders
    auto cancel_future = trading_client->cancel_all_orders(\"BTCUSDT\");
    bool success = cancel_future.get();
    
    EXPECT_TRUE(success);
    
    // Check remaining orders
    auto orders_future = trading_client->get_open_orders(\"\");
    auto orders = orders_future.get();
    
    // Should only have ETHUSDT order remaining
    EXPECT_EQ(orders.size(), 1);
    EXPECT_EQ(orders[0].symbol, \"ETHUSDT\");
}

TEST_F(TradingClientTest, GetOrderStatus) {
    EXPECT_TRUE(trading_client->connect());
    
    // Place an order
    auto place_future = trading_client->place_order(\"BTCUSDT\", hft::Side::BUY, hft::OrderType::LIMIT, 45000.0, 0.001);
    auto order_id = place_future.get();
    EXPECT_FALSE(order_id.empty());
    
    // Get order status
    auto status_future = trading_client->get_order_status(order_id);
    auto order = status_future.get();
    
    EXPECT_EQ(order.id, order_id);
    EXPECT_EQ(order.symbol, \"BTCUSDT\");
    EXPECT_EQ(order.side, hft::Side::BUY);
}

TEST_F(TradingClientTest, GetOrderStatusNonexistent) {
    EXPECT_TRUE(trading_client->connect());
    
    auto status_future = trading_client->get_order_status(\"NONEXISTENT_ORDER\");
    auto order = status_future.get();
    
    EXPECT_EQ(order.status, hft::OrderStatus::REJECTED);
}

TEST_F(TradingClientTest, GetTradeHistory) {
    EXPECT_TRUE(trading_client->connect());
    
    auto trades_future = trading_client->get_trade_history(\"BTCUSDT\", 10);
    auto trades = trades_future.get();
    
    // For mock implementation, should return empty vector
    EXPECT_TRUE(trades.empty());
}"
    }
  ]
}
