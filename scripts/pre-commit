#!/bin/bash

# HFT Engine Pre-commit Hook
# Ensures code quality before allowing commits to master branch
# Author: Raja Babu
# Date: 2025-07-10

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
PROTECTED_BRANCHES=("master" "main" "release")
MIN_COVERAGE_THRESHOLD=90

log_info() {
    echo -e "${BLUE}[PRE-COMMIT]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[PRE-COMMIT]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[PRE-COMMIT]${NC} $1"
}

log_error() {
    echo -e "${RED}[PRE-COMMIT]${NC} $1"
}

print_header() {
    echo "=================================================================="
    echo "                    HFT ENGINE PRE-COMMIT HOOK                   "
    echo "=================================================================="
    echo "Checking code quality before commit..."
    echo "=================================================================="
}

check_branch_protection() {
    local current_branch=$(git rev-parse --abbrev-ref HEAD)
    
    for protected_branch in "${PROTECTED_BRANCHES[@]}"; do
        if [ "$current_branch" = "$protected_branch" ]; then
            log_warning "Direct commits to '$protected_branch' require additional checks"
            return 0
        fi
    done
    
    log_info "Committing to branch: $current_branch"
    return 1
}

check_staged_files() {
    local staged_files=$(git diff --cached --name-only)
    
    if [ -z "$staged_files" ]; then
        log_error "No staged files found"
        return 1
    fi
    
    log_info "Staged files:"
    echo "$staged_files" | while read file; do
        echo "  - $file"
    done
    
    return 0
}

run_build_and_tests() {
    log_info "Running build and tests..."
    
    if [ -x "$SCRIPT_DIR/hft-build" ]; then
        # Run build with coverage for protected branches
        if check_branch_protection; then
            log_info "Running full build with coverage for protected branch"
            if "$SCRIPT_DIR/hft-build" --clean --coverage; then
                log_success "Build and tests passed with coverage"
                return 0
            else
                log_error "Build or tests failed"
                return 1
            fi
        else
            log_info "Running standard build and tests"
            if "$SCRIPT_DIR/hft-build"; then
                log_success "Build and tests passed"
                return 0
            else
                log_error "Build or tests failed"
                return 1
            fi
        fi
    else
        log_error "hft-build script not found or not executable"
        return 1
    fi
}

check_commit_message() {
    # Check if commit message follows conventional commits format
    local commit_msg_file="$1"
    
    if [ -f "$commit_msg_file" ]; then
        local commit_msg=$(cat "$commit_msg_file")
        
        # Check for conventional commit format: type(scope): description
        if echo "$commit_msg" | grep -qE "^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: .+"; then
            log_success "Commit message follows conventional format"
            return 0
        else
            log_warning "Commit message doesn't follow conventional format"
            log_info "Expected format: type(scope): description"
            log_info "Examples:"
            log_info "  feat(auth): add API key validation"
            log_info "  fix(trading): resolve order cancellation bug"
            log_info "  test(coverage): add comprehensive unit tests"
            # Don't fail for this, just warn
            return 0
        fi
    fi
    
    return 0
}

validate_cpp_files() {
    local cpp_files=$(git diff --cached --name-only | grep -E '\.(cpp|h|hpp)$' || true)
    
    if [ -n "$cpp_files" ]; then
        log_info "Validating C++ files..."
        
        # Check for basic code quality issues
        local issues_found=0
        
        echo "$cpp_files" | while read file; do
            if [ -f "$file" ]; then
                # Check for tab characters (prefer spaces)
                if grep -q $'\t' "$file"; then
                    log_warning "Found tab characters in $file (prefer spaces)"
                fi
                
                # Check for trailing whitespace
                if grep -q '[[:space:]]$' "$file"; then
                    log_warning "Found trailing whitespace in $file"
                fi
                
                # Check for very long lines (> 120 characters)
                local long_lines=$(awk 'length > 120 { print NR }' "$file" | wc -l)
                if [ "$long_lines" -gt 0 ]; then
                    log_warning "Found $long_lines lines > 120 characters in $file"
                fi
            fi
        done
        
        log_success "C++ file validation completed"
    fi
    
    return 0
}

main() {
    print_header
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        log_error "Not in a git repository"
        exit 1
    fi
    
    # Check staged files
    if ! check_staged_files; then
        exit 1
    fi
    
    # Validate C++ files
    validate_cpp_files
    
    # Run build and tests
    if ! run_build_and_tests; then
        log_error "Pre-commit checks failed"
        log_info "Please fix the issues and try again"
        exit 1
    fi
    
    # Check commit message format (if available)
    if [ -n "$1" ]; then
        check_commit_message "$1"
    fi
    
    log_success "All pre-commit checks passed!"
    log_info "Proceeding with commit..."
    
    exit 0
}

# Run main function with all arguments
main "$@"
