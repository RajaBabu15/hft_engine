#!/bin/bash

# HFT Engine Build Script
# Production-grade build system inspired by Amazon's brazil-build
# Author: Raja Babu
# Date: 2025-07-10

set -e  # Exit on any error

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
BUILD_DIR="$PROJECT_ROOT/build"
COVERAGE_DIR="$PROJECT_ROOT/coverage"
TEST_REPORTS_DIR="$PROJECT_ROOT/test_reports"
MIN_COVERAGE_THRESHOLD=90

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_banner() {
    echo "=================================================================="
    echo "                    HFT ENGINE BUILD SYSTEM                      "
    echo "=================================================================="
    echo "Project: High-Frequency Trading Engine"
    echo "Author:  Raja Babu"
    echo "Date:    $(date)"
    echo "=================================================================="
}

print_usage() {
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  --clean         Clean build directory before building"
    echo "  --test-only     Run tests only (skip build)"
    echo "  --coverage      Generate coverage report"
    echo "  --no-tests      Skip running tests"
    echo "  --release       Build in release mode (default: debug)"
    echo "  --commit        Commit changes if all checks pass"
    echo "  --help          Show this help message"
    echo ""
    echo "EXAMPLES:"
    echo "  $0                    # Standard build and test"
    echo "  $0 --clean --coverage # Clean build with coverage"
    echo "  $0 --commit           # Build, test, and commit if successful"
}

cleanup_on_exit() {
    local exit_code=$?
    if [ $exit_code -ne 0 ]; then
        log_error "Build failed with exit code $exit_code"
        log_info "Check the logs above for details"
    fi
    exit $exit_code
}

check_dependencies() {
    log_info "Checking dependencies..."
    
    local missing_deps=()
    
    if ! command -v cmake &> /dev/null; then
        missing_deps+=("cmake")
    fi
    
    if ! command -v make &> /dev/null; then
        missing_deps+=("make")
    fi
    
    if ! command -v gcov &> /dev/null; then
        missing_deps+=("gcov")
    fi
    
    if ! command -v lcov &> /dev/null; then
        log_warning "lcov not found - coverage reports will be limited"
    fi
    
    if [ ${#missing_deps[@]} -ne 0 ]; then
        log_error "Missing dependencies: ${missing_deps[*]}"
        log_info "Please install missing dependencies and try again"
        exit 1
    fi
    
    log_success "All dependencies found"
}

clean_build() {
    log_info "Cleaning build directory..."
    if [ -d "$BUILD_DIR" ]; then
        rm -rf "$BUILD_DIR"
        log_success "Build directory cleaned"
    fi
    
    if [ -d "$COVERAGE_DIR" ]; then
        rm -rf "$COVERAGE_DIR"
        log_success "Coverage directory cleaned"
    fi
    
    if [ -d "$TEST_REPORTS_DIR" ]; then
        rm -rf "$TEST_REPORTS_DIR"
        log_success "Test reports directory cleaned"
    fi
}

setup_directories() {
    log_info "Setting up build directories..."
    mkdir -p "$BUILD_DIR"
    mkdir -p "$COVERAGE_DIR"
    mkdir -p "$TEST_REPORTS_DIR"
    log_success "Directories created"
}

configure_project() {
    log_info "Configuring project with CMake..."
    cd "$BUILD_DIR"
    
    local cmake_args="-DCMAKE_EXPORT_COMPILE_COMMANDS=ON"
    
    if [ "$BUILD_TYPE" = "Release" ]; then
        cmake_args="$cmake_args -DCMAKE_BUILD_TYPE=Release"
    else
        cmake_args="$cmake_args -DCMAKE_BUILD_TYPE=Debug"
    fi
    
    if [ "$ENABLE_COVERAGE" = "true" ]; then
        cmake_args="$cmake_args -DENABLE_COVERAGE=ON"
    fi
    
    if cmake $cmake_args "$PROJECT_ROOT"; then
        log_success "Project configured successfully"
    else
        log_error "CMake configuration failed"
        exit 1
    fi
}

build_project() {
    log_info "Building project..."
    cd "$BUILD_DIR"
    
    local cpu_count=$(nproc 2>/dev/null || echo 4)
    
    if make -j"$cpu_count"; then
        log_success "Build completed successfully"
    else
        log_error "Build failed"
        exit 1
    fi
}

run_tests() {
    log_info "Running tests..."
    cd "$BUILD_DIR"
    
    # Set up test environment
    export GTEST_OUTPUT="xml:$TEST_REPORTS_DIR/gtest_results.xml"
    
    if ./hft_tests; then
        log_success "All tests passed"
        return 0
    else
        log_error "Tests failed"
        return 1
    fi
}

generate_coverage_report() {
    log_info "Generating coverage report..."
    cd "$BUILD_DIR"
    
    # Generate .gcov files
    gcov -r -b $(find . -name "*.gcno")
    
    # Check if lcov is available for HTML reports
    if command -v lcov &> /dev/null; then
        # Generate lcov info file
        lcov --capture --directory . --output-file "$COVERAGE_DIR/coverage.info"
        
        # Remove external libraries from coverage
        lcov --remove "$COVERAGE_DIR/coverage.info" '/usr/*' '*/external/*' '*/tests/*' --output-file "$COVERAGE_DIR/coverage_filtered.info"
        
        # Generate HTML report
        if command -v genhtml &> /dev/null; then
            genhtml "$COVERAGE_DIR/coverage_filtered.info" --output-directory "$COVERAGE_DIR/html"
            log_success "HTML coverage report generated in $COVERAGE_DIR/html"
        fi
        
        # Calculate coverage percentage
        local coverage_percent=$(lcov --summary "$COVERAGE_DIR/coverage_filtered.info" 2>&1 | grep "lines" | awk '{print $2}' | sed 's/%//')
        
        if [ -n "$coverage_percent" ]; then
            log_info "Code coverage: $coverage_percent%"
            
            if (( $(echo "$coverage_percent >= $MIN_COVERAGE_THRESHOLD" | bc -l) )); then
                log_success "Coverage threshold met ($coverage_percent% >= $MIN_COVERAGE_THRESHOLD%)"
                return 0
            else
                log_error "Coverage threshold not met ($coverage_percent% < $MIN_COVERAGE_THRESHOLD%)"
                return 1
            fi
        else
            log_warning "Could not determine coverage percentage"
            return 1
        fi
    else
        log_warning "lcov not available - generating basic coverage info"
        
        # Basic coverage calculation
        local total_lines=$(find . -name "*.gcov" -exec grep -c "^[[:space:]]*[0-9]" {} \; | awk '{sum+=$1} END {print sum}')
        local covered_lines=$(find . -name "*.gcov" -exec grep -c "^[[:space:]]*[1-9]" {} \; | awk '{sum+=$1} END {print sum}')
        
        if [ "$total_lines" -gt 0 ]; then
            local coverage_percent=$(echo "scale=2; $covered_lines * 100 / $total_lines" | bc)
            log_info "Code coverage: $coverage_percent%"
            
            if (( $(echo "$coverage_percent >= $MIN_COVERAGE_THRESHOLD" | bc -l) )); then
                log_success "Coverage threshold met"
                return 0
            else
                log_error "Coverage threshold not met"
                return 1
            fi
        else
            log_error "No coverage data found"
            return 1
        fi
    fi
}

validate_code_quality() {
    log_info "Running code quality checks..."
    
    # Check for common issues
    local issues_found=0
    
    # Check for TODO/FIXME comments
    local todo_count=$(find "$PROJECT_ROOT/src" "$PROJECT_ROOT/include" -name "*.cpp" -o -name "*.h" | xargs grep -c "TODO\|FIXME" 2>/dev/null | awk -F: '{sum+=$2} END {print sum+0}')
    if [ "$todo_count" -gt 0 ]; then
        log_warning "Found $todo_count TODO/FIXME comments"
    fi
    
    # Check for memory leaks (if valgrind is available)
    if command -v valgrind &> /dev/null; then
        log_info "Running memory leak detection..."
        if valgrind --error-exitcode=1 --leak-check=full --show-leak-kinds=all ./hft_tests > /dev/null 2>&1; then
            log_success "No memory leaks detected"
        else
            log_error "Memory leaks detected"
            issues_found=$((issues_found + 1))
        fi
    fi
    
    return $issues_found
}

commit_changes() {
    log_info "Committing changes..."
    cd "$PROJECT_ROOT"
    
    if [ -n "$(git status --porcelain)" ]; then
        git add .
        local commit_message="feat: Production build completed successfully

- All tests passed
- Code coverage: $coverage_percent%
- Build completed at: $(date)
- Commit made by hft-build script"
        
        git commit -m "$commit_message"
        log_success "Changes committed successfully"
        log_info "To push to remote: git push origin main"
    else
        log_info "No changes to commit"
    fi
}

# Parse command line arguments
CLEAN_BUILD=false
TEST_ONLY=false
ENABLE_COVERAGE=false
SKIP_TESTS=false
BUILD_TYPE="Debug"
AUTO_COMMIT=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --clean)
            CLEAN_BUILD=true
            shift
            ;;
        --test-only)
            TEST_ONLY=true
            shift
            ;;
        --coverage)
            ENABLE_COVERAGE=true
            shift
            ;;
        --no-tests)
            SKIP_TESTS=true
            shift
            ;;
        --release)
            BUILD_TYPE="Release"
            shift
            ;;
        --commit)
            AUTO_COMMIT=true
            shift
            ;;
        --help)
            print_usage
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            print_usage
            exit 1
            ;;
    esac
done

# Main execution
main() {
    trap cleanup_on_exit EXIT
    
    print_banner
    
    # Validate environment
    check_dependencies
    
    # Clean if requested
    if [ "$CLEAN_BUILD" = true ]; then
        clean_build
    fi
    
    # Skip build if test-only mode
    if [ "$TEST_ONLY" = false ]; then
        setup_directories
        configure_project
        build_project
    fi
    
    # Run tests unless skipped
    if [ "$SKIP_TESTS" = false ]; then
        if ! run_tests; then
            log_error "Tests failed - aborting build"
            exit 1
        fi
    fi
    
    # Generate coverage report if enabled
    if [ "$ENABLE_COVERAGE" = true ]; then
        if ! generate_coverage_report; then
            log_error "Coverage requirements not met - aborting build"
            exit 1
        fi
    fi
    
    # Run code quality checks
    validate_code_quality
    
    # Commit if requested and all checks passed
    if [ "$AUTO_COMMIT" = true ]; then
        commit_changes
    fi
    
    log_success "Build completed successfully!"
    
    # Print summary
    echo ""
    echo "=================================================================="
    echo "                        BUILD SUMMARY                            "
    echo "=================================================================="
    echo "Build Type:     $BUILD_TYPE"
    echo "Tests:          $([ "$SKIP_TESTS" = false ] && echo "PASSED" || echo "SKIPPED")"
    echo "Coverage:       $([ "$ENABLE_COVERAGE" = true ] && echo "GENERATED" || echo "DISABLED")"
    echo "Commit:         $([ "$AUTO_COMMIT" = true ] && echo "COMPLETED" || echo "MANUAL")"
    echo "=================================================================="
}

# Run main function
main "$@"
